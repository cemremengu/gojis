// Code generated from JavaScriptParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // JavaScriptParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 112, 781,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 3, 2, 5, 2, 124, 10, 2, 3, 2, 3, 2, 3, 3, 5, 3, 129,
	10, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
	3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 150, 10, 4, 3, 5,
	3, 5, 5, 5, 154, 10, 5, 3, 5, 3, 5, 3, 6, 6, 6, 159, 10, 6, 13, 6, 14,
	6, 160, 3, 7, 3, 7, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 7, 8, 170, 10, 8, 12,
	8, 14, 8, 173, 11, 8, 3, 9, 3, 9, 3, 9, 5, 9, 178, 10, 9, 3, 9, 3, 9, 5,
	9, 182, 10, 9, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 197, 10, 12, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 216, 10, 13, 3, 13, 3, 13, 5, 13, 220,
	10, 13, 3, 13, 3, 13, 5, 13, 224, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 5, 13, 234, 10, 13, 3, 13, 3, 13, 5, 13, 238,
	10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	5, 13, 249, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 5, 13, 262, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	5, 13, 268, 10, 13, 3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 5, 15, 275, 10,
	15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 5, 16, 282, 10, 16, 3, 16, 3, 16,
	3, 17, 3, 17, 3, 17, 5, 17, 289, 10, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 20,
	3, 20, 5, 20, 307, 10, 20, 3, 20, 3, 20, 5, 20, 311, 10, 20, 5, 20, 313,
	10, 20, 3, 20, 3, 20, 3, 21, 6, 21, 318, 10, 21, 13, 21, 14, 21, 319, 3,
	22, 3, 22, 3, 22, 3, 22, 5, 22, 326, 10, 22, 3, 23, 3, 23, 3, 23, 5, 23,
	331, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3,
	25, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 346, 10, 26, 3, 26, 5, 26, 349,
	10, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 3, 28,
	3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 367, 10, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32,
	5, 32, 380, 10, 32, 3, 32, 3, 32, 7, 32, 384, 10, 32, 12, 32, 14, 32, 387,
	11, 32, 3, 32, 3, 32, 3, 33, 3, 33, 3, 33, 5, 33, 394, 10, 33, 3, 33, 3,
	33, 5, 33, 398, 10, 33, 3, 34, 3, 34, 3, 34, 5, 34, 403, 10, 34, 3, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 5, 34, 420, 10, 34, 3, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 5, 34, 428, 10, 34, 3, 35, 5, 35, 431, 10, 35, 3, 35, 3,
	35, 3, 35, 5, 35, 436, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 36,
	3, 36, 3, 36, 7, 36, 446, 10, 36, 12, 36, 14, 36, 449, 11, 36, 3, 36, 3,
	36, 5, 36, 453, 10, 36, 3, 36, 3, 36, 3, 36, 5, 36, 458, 10, 36, 3, 37,
	3, 37, 3, 37, 5, 37, 463, 10, 37, 3, 38, 3, 38, 3, 38, 3, 39, 5, 39, 469,
	10, 39, 3, 40, 6, 40, 472, 10, 40, 13, 40, 14, 40, 473, 3, 41, 3, 41, 7,
	41, 478, 10, 41, 12, 41, 14, 41, 481, 11, 41, 3, 41, 5, 41, 484, 10, 41,
	3, 41, 7, 41, 487, 10, 41, 12, 41, 14, 41, 490, 11, 41, 3, 41, 3, 41, 3,
	42, 3, 42, 6, 42, 496, 10, 42, 13, 42, 14, 42, 497, 3, 42, 7, 42, 501,
	10, 42, 12, 42, 14, 42, 504, 11, 42, 3, 42, 6, 42, 507, 10, 42, 13, 42,
	14, 42, 508, 3, 42, 5, 42, 512, 10, 42, 3, 42, 5, 42, 515, 10, 42, 3, 43,
	3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 7, 44, 524, 10, 44, 12, 44, 14,
	44, 527, 11, 44, 5, 44, 529, 10, 44, 3, 44, 5, 44, 532, 10, 44, 3, 44,
	3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 563, 10, 45, 3,
	46, 3, 46, 3, 46, 5, 46, 568, 10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 7, 47,
	574, 10, 47, 12, 47, 14, 47, 577, 11, 47, 3, 47, 3, 47, 5, 47, 581, 10,
	47, 3, 47, 5, 47, 584, 10, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 49,
	3, 49, 3, 49, 7, 49, 594, 10, 49, 12, 49, 14, 49, 597, 11, 49, 3, 50, 3,
	50, 3, 50, 5, 50, 602, 10, 50, 3, 50, 3, 50, 5, 50, 606, 10, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 615, 10, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 5, 50, 621, 10, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 655, 10, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 7, 50, 724, 10, 50, 12, 50, 14, 50, 727, 11, 50, 3, 51,
	3, 51, 3, 51, 5, 51, 732, 10, 51, 3, 51, 5, 51, 735, 10, 51, 3, 52, 3,
	52, 3, 52, 3, 52, 3, 52, 5, 52, 742, 10, 52, 3, 53, 3, 53, 3, 54, 3, 54,
	3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 752, 10, 54, 3, 55, 3, 55, 3, 56, 3,
	56, 5, 56, 758, 10, 56, 3, 57, 3, 57, 3, 57, 5, 57, 763, 10, 57, 3, 58,
	3, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 61, 3,
	61, 3, 61, 3, 61, 5, 61, 779, 10, 61, 3, 61, 2, 3, 98, 62, 2, 4, 6, 8,
	10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
	46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
	82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 2, 12, 5, 2, 70, 70, 93, 93, 97, 97, 4, 2, 14, 14,
	16, 16, 3, 2, 25, 27, 3, 2, 21, 22, 3, 2, 28, 30, 3, 2, 31, 34, 3, 2, 35,
	38, 3, 2, 44, 54, 3, 2, 58, 62, 3, 2, 63, 104, 2, 870, 2, 123, 3, 2, 2,
	2, 4, 128, 3, 2, 2, 2, 6, 149, 3, 2, 2, 2, 8, 151, 3, 2, 2, 2, 10, 158,
	3, 2, 2, 2, 12, 162, 3, 2, 2, 2, 14, 166, 3, 2, 2, 2, 16, 177, 3, 2, 2,
	2, 18, 183, 3, 2, 2, 2, 20, 185, 3, 2, 2, 2, 22, 189, 3, 2, 2, 2, 24, 267,
	3, 2, 2, 2, 26, 269, 3, 2, 2, 2, 28, 271, 3, 2, 2, 2, 30, 278, 3, 2, 2,
	2, 32, 285, 3, 2, 2, 2, 34, 292, 3, 2, 2, 2, 36, 298, 3, 2, 2, 2, 38, 304,
	3, 2, 2, 2, 40, 317, 3, 2, 2, 2, 42, 321, 3, 2, 2, 2, 44, 327, 3, 2, 2,
	2, 46, 332, 3, 2, 2, 2, 48, 336, 3, 2, 2, 2, 50, 341, 3, 2, 2, 2, 52, 350,
	3, 2, 2, 2, 54, 356, 3, 2, 2, 2, 56, 359, 3, 2, 2, 2, 58, 362, 3, 2, 2,
	2, 60, 373, 3, 2, 2, 2, 62, 379, 3, 2, 2, 2, 64, 397, 3, 2, 2, 2, 66, 427,
	3, 2, 2, 2, 68, 430, 3, 2, 2, 2, 70, 457, 3, 2, 2, 2, 72, 459, 3, 2, 2,
	2, 74, 464, 3, 2, 2, 2, 76, 468, 3, 2, 2, 2, 78, 471, 3, 2, 2, 2, 80, 475,
	3, 2, 2, 2, 82, 514, 3, 2, 2, 2, 84, 516, 3, 2, 2, 2, 86, 519, 3, 2, 2,
	2, 88, 562, 3, 2, 2, 2, 90, 567, 3, 2, 2, 2, 92, 569, 3, 2, 2, 2, 94, 587,
	3, 2, 2, 2, 96, 590, 3, 2, 2, 2, 98, 654, 3, 2, 2, 2, 100, 734, 3, 2, 2,
	2, 102, 741, 3, 2, 2, 2, 104, 743, 3, 2, 2, 2, 106, 751, 3, 2, 2, 2, 108,
	753, 3, 2, 2, 2, 110, 757, 3, 2, 2, 2, 112, 762, 3, 2, 2, 2, 114, 764,
	3, 2, 2, 2, 116, 766, 3, 2, 2, 2, 118, 770, 3, 2, 2, 2, 120, 778, 3, 2,
	2, 2, 122, 124, 5, 78, 40, 2, 123, 122, 3, 2, 2, 2, 123, 124, 3, 2, 2,
	2, 124, 125, 3, 2, 2, 2, 125, 126, 7, 2, 2, 3, 126, 3, 3, 2, 2, 2, 127,
	129, 7, 94, 2, 2, 128, 127, 3, 2, 2, 2, 128, 129, 3, 2, 2, 2, 129, 130,
	3, 2, 2, 2, 130, 131, 5, 6, 4, 2, 131, 5, 3, 2, 2, 2, 132, 150, 5, 8, 5,
	2, 133, 150, 5, 12, 7, 2, 134, 150, 5, 18, 10, 2, 135, 150, 5, 60, 31,
	2, 136, 150, 5, 20, 11, 2, 137, 150, 5, 22, 12, 2, 138, 150, 5, 24, 13,
	2, 139, 150, 5, 28, 15, 2, 140, 150, 5, 30, 16, 2, 141, 150, 5, 32, 17,
	2, 142, 150, 5, 34, 18, 2, 143, 150, 5, 46, 24, 2, 144, 150, 5, 36, 19,
	2, 145, 150, 5, 48, 25, 2, 146, 150, 5, 50, 26, 2, 147, 150, 5, 56, 29,
	2, 148, 150, 5, 58, 30, 2, 149, 132, 3, 2, 2, 2, 149, 133, 3, 2, 2, 2,
	149, 134, 3, 2, 2, 2, 149, 135, 3, 2, 2, 2, 149, 136, 3, 2, 2, 2, 149,
	137, 3, 2, 2, 2, 149, 138, 3, 2, 2, 2, 149, 139, 3, 2, 2, 2, 149, 140,
	3, 2, 2, 2, 149, 141, 3, 2, 2, 2, 149, 142, 3, 2, 2, 2, 149, 143, 3, 2,
	2, 2, 149, 144, 3, 2, 2, 2, 149, 145, 3, 2, 2, 2, 149, 146, 3, 2, 2, 2,
	149, 147, 3, 2, 2, 2, 149, 148, 3, 2, 2, 2, 150, 7, 3, 2, 2, 2, 151, 153,
	7, 10, 2, 2, 152, 154, 5, 10, 6, 2, 153, 152, 3, 2, 2, 2, 153, 154, 3,
	2, 2, 2, 154, 155, 3, 2, 2, 2, 155, 156, 7, 11, 2, 2, 156, 9, 3, 2, 2,
	2, 157, 159, 5, 6, 4, 2, 158, 157, 3, 2, 2, 2, 159, 160, 3, 2, 2, 2, 160,
	158, 3, 2, 2, 2, 160, 161, 3, 2, 2, 2, 161, 11, 3, 2, 2, 2, 162, 163, 5,
	26, 14, 2, 163, 164, 5, 14, 8, 2, 164, 165, 5, 120, 61, 2, 165, 13, 3,
	2, 2, 2, 166, 171, 5, 16, 9, 2, 167, 168, 7, 13, 2, 2, 168, 170, 5, 16,
	9, 2, 169, 167, 3, 2, 2, 2, 170, 173, 3, 2, 2, 2, 171, 169, 3, 2, 2, 2,
	171, 172, 3, 2, 2, 2, 172, 15, 3, 2, 2, 2, 173, 171, 3, 2, 2, 2, 174, 178,
	7, 105, 2, 2, 175, 178, 5, 80, 41, 2, 176, 178, 5, 86, 44, 2, 177, 174,
	3, 2, 2, 2, 177, 175, 3, 2, 2, 2, 177, 176, 3, 2, 2, 2, 178, 181, 3, 2,
	2, 2, 179, 180, 7, 14, 2, 2, 180, 182, 5, 98, 50, 2, 181, 179, 3, 2, 2,
	2, 181, 182, 3, 2, 2, 2, 182, 17, 3, 2, 2, 2, 183, 184, 7, 12, 2, 2, 184,
	19, 3, 2, 2, 2, 185, 186, 6, 11, 2, 2, 186, 187, 5, 96, 49, 2, 187, 188,
	5, 120, 61, 2, 188, 21, 3, 2, 2, 2, 189, 190, 7, 84, 2, 2, 190, 191, 7,
	8, 2, 2, 191, 192, 5, 96, 49, 2, 192, 193, 7, 9, 2, 2, 193, 196, 5, 6,
	4, 2, 194, 195, 7, 68, 2, 2, 195, 197, 5, 6, 4, 2, 196, 194, 3, 2, 2, 2,
	196, 197, 3, 2, 2, 2, 197, 23, 3, 2, 2, 2, 198, 199, 7, 64, 2, 2, 199,
	200, 5, 6, 4, 2, 200, 201, 7, 78, 2, 2, 201, 202, 7, 8, 2, 2, 202, 203,
	5, 96, 49, 2, 203, 204, 7, 9, 2, 2, 204, 205, 5, 120, 61, 2, 205, 268,
	3, 2, 2, 2, 206, 207, 7, 78, 2, 2, 207, 208, 7, 8, 2, 2, 208, 209, 5, 96,
	49, 2, 209, 210, 7, 9, 2, 2, 210, 211, 5, 6, 4, 2, 211, 268, 3, 2, 2, 2,
	212, 213, 7, 76, 2, 2, 213, 215, 7, 8, 2, 2, 214, 216, 5, 96, 49, 2, 215,
	214, 3, 2, 2, 2, 215, 216, 3, 2, 2, 2, 216, 217, 3, 2, 2, 2, 217, 219,
	7, 12, 2, 2, 218, 220, 5, 96, 49, 2, 219, 218, 3, 2, 2, 2, 219, 220, 3,
	2, 2, 2, 220, 221, 3, 2, 2, 2, 221, 223, 7, 12, 2, 2, 222, 224, 5, 96,
	49, 2, 223, 222, 3, 2, 2, 2, 223, 224, 3, 2, 2, 2, 224, 225, 3, 2, 2, 2,
	225, 226, 7, 9, 2, 2, 226, 268, 5, 6, 4, 2, 227, 228, 7, 76, 2, 2, 228,
	229, 7, 8, 2, 2, 229, 230, 5, 26, 14, 2, 230, 231, 5, 14, 8, 2, 231, 233,
	7, 12, 2, 2, 232, 234, 5, 96, 49, 2, 233, 232, 3, 2, 2, 2, 233, 234, 3,
	2, 2, 2, 234, 235, 3, 2, 2, 2, 235, 237, 7, 12, 2, 2, 236, 238, 5, 96,
	49, 2, 237, 236, 3, 2, 2, 2, 237, 238, 3, 2, 2, 2, 238, 239, 3, 2, 2, 2,
	239, 240, 7, 9, 2, 2, 240, 241, 5, 6, 4, 2, 241, 268, 3, 2, 2, 2, 242,
	243, 7, 76, 2, 2, 243, 244, 7, 8, 2, 2, 244, 248, 5, 98, 50, 2, 245, 249,
	7, 87, 2, 2, 246, 247, 7, 105, 2, 2, 247, 249, 6, 13, 3, 2, 248, 245, 3,
	2, 2, 2, 248, 246, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250, 251, 5, 96, 49,
	2, 251, 252, 7, 9, 2, 2, 252, 253, 5, 6, 4, 2, 253, 268, 3, 2, 2, 2, 254,
	255, 7, 76, 2, 2, 255, 256, 7, 8, 2, 2, 256, 257, 5, 26, 14, 2, 257, 261,
	5, 16, 9, 2, 258, 262, 7, 87, 2, 2, 259, 260, 7, 105, 2, 2, 260, 262, 6,
	13, 4, 2, 261, 258, 3, 2, 2, 2, 261, 259, 3, 2, 2, 2, 262, 263, 3, 2, 2,
	2, 263, 264, 5, 96, 49, 2, 264, 265, 7, 9, 2, 2, 265, 266, 5, 6, 4, 2,
	266, 268, 3, 2, 2, 2, 267, 198, 3, 2, 2, 2, 267, 206, 3, 2, 2, 2, 267,
	212, 3, 2, 2, 2, 267, 227, 3, 2, 2, 2, 267, 242, 3, 2, 2, 2, 267, 254,
	3, 2, 2, 2, 268, 25, 3, 2, 2, 2, 269, 270, 9, 2, 2, 2, 270, 27, 3, 2, 2,
	2, 271, 274, 7, 75, 2, 2, 272, 273, 6, 15, 5, 2, 273, 275, 7, 105, 2, 2,
	274, 272, 3, 2, 2, 2, 274, 275, 3, 2, 2, 2, 275, 276, 3, 2, 2, 2, 276,
	277, 5, 120, 61, 2, 277, 29, 3, 2, 2, 2, 278, 281, 7, 63, 2, 2, 279, 280,
	6, 16, 6, 2, 280, 282, 7, 105, 2, 2, 281, 279, 3, 2, 2, 2, 281, 282, 3,
	2, 2, 2, 282, 283, 3, 2, 2, 2, 283, 284, 5, 120, 61, 2, 284, 31, 3, 2,
	2, 2, 285, 288, 7, 73, 2, 2, 286, 287, 6, 17, 7, 2, 287, 289, 5, 96, 49,
	2, 288, 286, 3, 2, 2, 2, 288, 289, 3, 2, 2, 2, 289, 290, 3, 2, 2, 2, 290,
	291, 5, 120, 61, 2, 291, 33, 3, 2, 2, 2, 292, 293, 7, 82, 2, 2, 293, 294,
	7, 8, 2, 2, 294, 295, 5, 96, 49, 2, 295, 296, 7, 9, 2, 2, 296, 297, 5,
	6, 4, 2, 297, 35, 3, 2, 2, 2, 298, 299, 7, 77, 2, 2, 299, 300, 7, 8, 2,
	2, 300, 301, 5, 96, 49, 2, 301, 302, 7, 9, 2, 2, 302, 303, 5, 38, 20, 2,
	303, 37, 3, 2, 2, 2, 304, 306, 7, 10, 2, 2, 305, 307, 5, 40, 21, 2, 306,
	305, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2, 307, 312, 3, 2, 2, 2, 308, 310,
	5, 44, 23, 2, 309, 311, 5, 40, 21, 2, 310, 309, 3, 2, 2, 2, 310, 311, 3,
	2, 2, 2, 311, 313, 3, 2, 2, 2, 312, 308, 3, 2, 2, 2, 312, 313, 3, 2, 2,
	2, 313, 314, 3, 2, 2, 2, 314, 315, 7, 11, 2, 2, 315, 39, 3, 2, 2, 2, 316,
	318, 5, 42, 22, 2, 317, 316, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319, 317,
	3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 320, 41, 3, 2, 2, 2, 321, 322, 7, 67,
	2, 2, 322, 323, 5, 96, 49, 2, 323, 325, 7, 16, 2, 2, 324, 326, 5, 10, 6,
	2, 325, 324, 3, 2, 2, 2, 325, 326, 3, 2, 2, 2, 326, 43, 3, 2, 2, 2, 327,
	328, 7, 83, 2, 2, 328, 330, 7, 16, 2, 2, 329, 331, 5, 10, 6, 2, 330, 329,
	3, 2, 2, 2, 330, 331, 3, 2, 2, 2, 331, 45, 3, 2, 2, 2, 332, 333, 7, 105,
	2, 2, 333, 334, 7, 16, 2, 2, 334, 335, 5, 6, 4, 2, 335, 47, 3, 2, 2, 2,
	336, 337, 7, 85, 2, 2, 337, 338, 6, 25, 8, 2, 338, 339, 5, 96, 49, 2, 339,
	340, 5, 120, 61, 2, 340, 49, 3, 2, 2, 2, 341, 342, 7, 88, 2, 2, 342, 348,
	5, 8, 5, 2, 343, 345, 5, 52, 27, 2, 344, 346, 5, 54, 28, 2, 345, 344, 3,
	2, 2, 2, 345, 346, 3, 2, 2, 2, 346, 349, 3, 2, 2, 2, 347, 349, 5, 54, 28,
	2, 348, 343, 3, 2, 2, 2, 348, 347, 3, 2, 2, 2, 349, 51, 3, 2, 2, 2, 350,
	351, 7, 71, 2, 2, 351, 352, 7, 8, 2, 2, 352, 353, 7, 105, 2, 2, 353, 354,
	7, 9, 2, 2, 354, 355, 5, 8, 5, 2, 355, 53, 3, 2, 2, 2, 356, 357, 7, 72,
	2, 2, 357, 358, 5, 8, 5, 2, 358, 55, 3, 2, 2, 2, 359, 360, 7, 79, 2, 2,
	360, 361, 5, 120, 61, 2, 361, 57, 3, 2, 2, 2, 362, 363, 7, 80, 2, 2, 363,
	364, 7, 105, 2, 2, 364, 366, 7, 8, 2, 2, 365, 367, 5, 70, 36, 2, 366, 365,
	3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 368, 3, 2, 2, 2, 368, 369, 7, 9,
	2, 2, 369, 370, 7, 10, 2, 2, 370, 371, 5, 76, 39, 2, 371, 372, 7, 11, 2,
	2, 372, 59, 3, 2, 2, 2, 373, 374, 7, 89, 2, 2, 374, 375, 7, 105, 2, 2,
	375, 376, 5, 62, 32, 2, 376, 61, 3, 2, 2, 2, 377, 378, 7, 91, 2, 2, 378,
	380, 5, 98, 50, 2, 379, 377, 3, 2, 2, 2, 379, 380, 3, 2, 2, 2, 380, 381,
	3, 2, 2, 2, 381, 385, 7, 10, 2, 2, 382, 384, 5, 64, 33, 2, 383, 382, 3,
	2, 2, 2, 384, 387, 3, 2, 2, 2, 385, 383, 3, 2, 2, 2, 385, 386, 3, 2, 2,
	2, 386, 388, 3, 2, 2, 2, 387, 385, 3, 2, 2, 2, 388, 389, 7, 11, 2, 2, 389,
	63, 3, 2, 2, 2, 390, 394, 7, 103, 2, 2, 391, 392, 6, 33, 9, 2, 392, 394,
	7, 105, 2, 2, 393, 390, 3, 2, 2, 2, 393, 391, 3, 2, 2, 2, 393, 394, 3,
	2, 2, 2, 394, 395, 3, 2, 2, 2, 395, 398, 5, 66, 34, 2, 396, 398, 5, 18,
	10, 2, 397, 393, 3, 2, 2, 2, 397, 396, 3, 2, 2, 2, 398, 65, 3, 2, 2, 2,
	399, 400, 5, 90, 46, 2, 400, 402, 7, 8, 2, 2, 401, 403, 5, 70, 36, 2, 402,
	401, 3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 404, 3, 2, 2, 2, 404, 405,
	7, 9, 2, 2, 405, 406, 7, 10, 2, 2, 406, 407, 5, 76, 39, 2, 407, 408, 7,
	11, 2, 2, 408, 428, 3, 2, 2, 2, 409, 410, 5, 116, 59, 2, 410, 411, 7, 8,
	2, 2, 411, 412, 7, 9, 2, 2, 412, 413, 7, 10, 2, 2, 413, 414, 5, 76, 39,
	2, 414, 415, 7, 11, 2, 2, 415, 428, 3, 2, 2, 2, 416, 417, 5, 118, 60, 2,
	417, 419, 7, 8, 2, 2, 418, 420, 5, 70, 36, 2, 419, 418, 3, 2, 2, 2, 419,
	420, 3, 2, 2, 2, 420, 421, 3, 2, 2, 2, 421, 422, 7, 9, 2, 2, 422, 423,
	7, 10, 2, 2, 423, 424, 5, 76, 39, 2, 424, 425, 7, 11, 2, 2, 425, 428, 3,
	2, 2, 2, 426, 428, 5, 68, 35, 2, 427, 399, 3, 2, 2, 2, 427, 409, 3, 2,
	2, 2, 427, 416, 3, 2, 2, 2, 427, 426, 3, 2, 2, 2, 428, 67, 3, 2, 2, 2,
	429, 431, 7, 25, 2, 2, 430, 429, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431,
	432, 3, 2, 2, 2, 432, 433, 7, 105, 2, 2, 433, 435, 7, 8, 2, 2, 434, 436,
	5, 70, 36, 2, 435, 434, 3, 2, 2, 2, 435, 436, 3, 2, 2, 2, 436, 437, 3,
	2, 2, 2, 437, 438, 7, 9, 2, 2, 438, 439, 7, 10, 2, 2, 439, 440, 5, 76,
	39, 2, 440, 441, 7, 11, 2, 2, 441, 69, 3, 2, 2, 2, 442, 447, 5, 72, 37,
	2, 443, 444, 7, 13, 2, 2, 444, 446, 5, 72, 37, 2, 445, 443, 3, 2, 2, 2,
	446, 449, 3, 2, 2, 2, 447, 445, 3, 2, 2, 2, 447, 448, 3, 2, 2, 2, 448,
	452, 3, 2, 2, 2, 449, 447, 3, 2, 2, 2, 450, 451, 7, 13, 2, 2, 451, 453,
	5, 74, 38, 2, 452, 450, 3, 2, 2, 2, 452, 453, 3, 2, 2, 2, 453, 458, 3,
	2, 2, 2, 454, 458, 5, 74, 38, 2, 455, 458, 5, 80, 41, 2, 456, 458, 5, 86,
	44, 2, 457, 442, 3, 2, 2, 2, 457, 454, 3, 2, 2, 2, 457, 455, 3, 2, 2, 2,
	457, 456, 3, 2, 2, 2, 458, 71, 3, 2, 2, 2, 459, 462, 7, 105, 2, 2, 460,
	461, 7, 14, 2, 2, 461, 463, 5, 98, 50, 2, 462, 460, 3, 2, 2, 2, 462, 463,
	3, 2, 2, 2, 463, 73, 3, 2, 2, 2, 464, 465, 7, 17, 2, 2, 465, 466, 7, 105,
	2, 2, 466, 75, 3, 2, 2, 2, 467, 469, 5, 78, 40, 2, 468, 467, 3, 2, 2, 2,
	468, 469, 3, 2, 2, 2, 469, 77, 3, 2, 2, 2, 470, 472, 5, 4, 3, 2, 471, 470,
	3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 471, 3, 2, 2, 2, 473, 474, 3, 2,
	2, 2, 474, 79, 3, 2, 2, 2, 475, 479, 7, 6, 2, 2, 476, 478, 7, 13, 2, 2,
	477, 476, 3, 2, 2, 2, 478, 481, 3, 2, 2, 2, 479, 477, 3, 2, 2, 2, 479,
	480, 3, 2, 2, 2, 480, 483, 3, 2, 2, 2, 481, 479, 3, 2, 2, 2, 482, 484,
	5, 82, 42, 2, 483, 482, 3, 2, 2, 2, 483, 484, 3, 2, 2, 2, 484, 488, 3,
	2, 2, 2, 485, 487, 7, 13, 2, 2, 486, 485, 3, 2, 2, 2, 487, 490, 3, 2, 2,
	2, 488, 486, 3, 2, 2, 2, 488, 489, 3, 2, 2, 2, 489, 491, 3, 2, 2, 2, 490,
	488, 3, 2, 2, 2, 491, 492, 7, 7, 2, 2, 492, 81, 3, 2, 2, 2, 493, 502, 5,
	98, 50, 2, 494, 496, 7, 13, 2, 2, 495, 494, 3, 2, 2, 2, 496, 497, 3, 2,
	2, 2, 497, 495, 3, 2, 2, 2, 497, 498, 3, 2, 2, 2, 498, 499, 3, 2, 2, 2,
	499, 501, 5, 98, 50, 2, 500, 495, 3, 2, 2, 2, 501, 504, 3, 2, 2, 2, 502,
	500, 3, 2, 2, 2, 502, 503, 3, 2, 2, 2, 503, 511, 3, 2, 2, 2, 504, 502,
	3, 2, 2, 2, 505, 507, 7, 13, 2, 2, 506, 505, 3, 2, 2, 2, 507, 508, 3, 2,
	2, 2, 508, 506, 3, 2, 2, 2, 508, 509, 3, 2, 2, 2, 509, 510, 3, 2, 2, 2,
	510, 512, 5, 84, 43, 2, 511, 506, 3, 2, 2, 2, 511, 512, 3, 2, 2, 2, 512,
	515, 3, 2, 2, 2, 513, 515, 5, 84, 43, 2, 514, 493, 3, 2, 2, 2, 514, 513,
	3, 2, 2, 2, 515, 83, 3, 2, 2, 2, 516, 517, 7, 17, 2, 2, 517, 518, 7, 105,
	2, 2, 518, 85, 3, 2, 2, 2, 519, 528, 7, 10, 2, 2, 520, 525, 5, 88, 45,
	2, 521, 522, 7, 13, 2, 2, 522, 524, 5, 88, 45, 2, 523, 521, 3, 2, 2, 2,
	524, 527, 3, 2, 2, 2, 525, 523, 3, 2, 2, 2, 525, 526, 3, 2, 2, 2, 526,
	529, 3, 2, 2, 2, 527, 525, 3, 2, 2, 2, 528, 520, 3, 2, 2, 2, 528, 529,
	3, 2, 2, 2, 529, 531, 3, 2, 2, 2, 530, 532, 7, 13, 2, 2, 531, 530, 3, 2,
	2, 2, 531, 532, 3, 2, 2, 2, 532, 533, 3, 2, 2, 2, 533, 534, 7, 11, 2, 2,
	534, 87, 3, 2, 2, 2, 535, 536, 5, 90, 46, 2, 536, 537, 9, 3, 2, 2, 537,
	538, 5, 98, 50, 2, 538, 563, 3, 2, 2, 2, 539, 540, 7, 6, 2, 2, 540, 541,
	5, 98, 50, 2, 541, 542, 7, 7, 2, 2, 542, 543, 7, 16, 2, 2, 543, 544, 5,
	98, 50, 2, 544, 563, 3, 2, 2, 2, 545, 546, 5, 116, 59, 2, 546, 547, 7,
	8, 2, 2, 547, 548, 7, 9, 2, 2, 548, 549, 7, 10, 2, 2, 549, 550, 5, 76,
	39, 2, 550, 551, 7, 11, 2, 2, 551, 563, 3, 2, 2, 2, 552, 553, 5, 118, 60,
	2, 553, 554, 7, 8, 2, 2, 554, 555, 7, 105, 2, 2, 555, 556, 7, 9, 2, 2,
	556, 557, 7, 10, 2, 2, 557, 558, 5, 76, 39, 2, 558, 559, 7, 11, 2, 2, 559,
	563, 3, 2, 2, 2, 560, 563, 5, 68, 35, 2, 561, 563, 7, 105, 2, 2, 562, 535,
	3, 2, 2, 2, 562, 539, 3, 2, 2, 2, 562, 545, 3, 2, 2, 2, 562, 552, 3, 2,
	2, 2, 562, 560, 3, 2, 2, 2, 562, 561, 3, 2, 2, 2, 563, 89, 3, 2, 2, 2,
	564, 568, 5, 110, 56, 2, 565, 568, 7, 106, 2, 2, 566, 568, 5, 108, 55,
	2, 567, 564, 3, 2, 2, 2, 567, 565, 3, 2, 2, 2, 567, 566, 3, 2, 2, 2, 568,
	91, 3, 2, 2, 2, 569, 583, 7, 8, 2, 2, 570, 575, 5, 98, 50, 2, 571, 572,
	7, 13, 2, 2, 572, 574, 5, 98, 50, 2, 573, 571, 3, 2, 2, 2, 574, 577, 3,
	2, 2, 2, 575, 573, 3, 2, 2, 2, 575, 576, 3, 2, 2, 2, 576, 580, 3, 2, 2,
	2, 577, 575, 3, 2, 2, 2, 578, 579, 7, 13, 2, 2, 579, 581, 5, 94, 48, 2,
	580, 578, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 584, 3, 2, 2, 2, 582,
	584, 5, 94, 48, 2, 583, 570, 3, 2, 2, 2, 583, 582, 3, 2, 2, 2, 583, 584,
	3, 2, 2, 2, 584, 585, 3, 2, 2, 2, 585, 586, 7, 9, 2, 2, 586, 93, 3, 2,
	2, 2, 587, 588, 7, 17, 2, 2, 588, 589, 7, 105, 2, 2, 589, 95, 3, 2, 2,
	2, 590, 595, 5, 98, 50, 2, 591, 592, 7, 13, 2, 2, 592, 594, 5, 98, 50,
	2, 593, 591, 3, 2, 2, 2, 594, 597, 3, 2, 2, 2, 595, 593, 3, 2, 2, 2, 595,
	596, 3, 2, 2, 2, 596, 97, 3, 2, 2, 2, 597, 595, 3, 2, 2, 2, 598, 599, 8,
	50, 1, 2, 599, 601, 7, 80, 2, 2, 600, 602, 7, 105, 2, 2, 601, 600, 3, 2,
	2, 2, 601, 602, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2, 603, 605, 7, 8, 2, 2,
	604, 606, 5, 70, 36, 2, 605, 604, 3, 2, 2, 2, 605, 606, 3, 2, 2, 2, 606,
	607, 3, 2, 2, 2, 607, 608, 7, 9, 2, 2, 608, 609, 7, 10, 2, 2, 609, 610,
	5, 76, 39, 2, 610, 611, 7, 11, 2, 2, 611, 655, 3, 2, 2, 2, 612, 614, 7,
	89, 2, 2, 613, 615, 7, 105, 2, 2, 614, 613, 3, 2, 2, 2, 614, 615, 3, 2,
	2, 2, 615, 616, 3, 2, 2, 2, 616, 655, 5, 62, 32, 2, 617, 618, 7, 69, 2,
	2, 618, 620, 5, 98, 50, 2, 619, 621, 5, 92, 47, 2, 620, 619, 3, 2, 2, 2,
	620, 621, 3, 2, 2, 2, 621, 655, 3, 2, 2, 2, 622, 623, 7, 86, 2, 2, 623,
	655, 5, 98, 50, 35, 624, 625, 7, 74, 2, 2, 625, 655, 5, 98, 50, 34, 626,
	627, 7, 66, 2, 2, 627, 655, 5, 98, 50, 33, 628, 629, 7, 19, 2, 2, 629,
	655, 5, 98, 50, 32, 630, 631, 7, 20, 2, 2, 631, 655, 5, 98, 50, 31, 632,
	633, 7, 21, 2, 2, 633, 655, 5, 98, 50, 30, 634, 635, 7, 22, 2, 2, 635,
	655, 5, 98, 50, 29, 636, 637, 7, 23, 2, 2, 637, 655, 5, 98, 50, 28, 638,
	639, 7, 24, 2, 2, 639, 655, 5, 98, 50, 27, 640, 655, 7, 81, 2, 2, 641,
	655, 7, 105, 2, 2, 642, 655, 7, 92, 2, 2, 643, 655, 5, 106, 54, 2, 644,
	655, 5, 80, 41, 2, 645, 655, 5, 86, 44, 2, 646, 647, 7, 8, 2, 2, 647, 648,
	5, 96, 49, 2, 648, 649, 7, 9, 2, 2, 649, 655, 3, 2, 2, 2, 650, 651, 5,
	100, 51, 2, 651, 652, 7, 55, 2, 2, 652, 653, 5, 102, 52, 2, 653, 655, 3,
	2, 2, 2, 654, 598, 3, 2, 2, 2, 654, 612, 3, 2, 2, 2, 654, 617, 3, 2, 2,
	2, 654, 622, 3, 2, 2, 2, 654, 624, 3, 2, 2, 2, 654, 626, 3, 2, 2, 2, 654,
	628, 3, 2, 2, 2, 654, 630, 3, 2, 2, 2, 654, 632, 3, 2, 2, 2, 654, 634,
	3, 2, 2, 2, 654, 636, 3, 2, 2, 2, 654, 638, 3, 2, 2, 2, 654, 640, 3, 2,
	2, 2, 654, 641, 3, 2, 2, 2, 654, 642, 3, 2, 2, 2, 654, 643, 3, 2, 2, 2,
	654, 644, 3, 2, 2, 2, 654, 645, 3, 2, 2, 2, 654, 646, 3, 2, 2, 2, 654,
	650, 3, 2, 2, 2, 655, 725, 3, 2, 2, 2, 656, 657, 12, 26, 2, 2, 657, 658,
	9, 4, 2, 2, 658, 724, 5, 98, 50, 27, 659, 660, 12, 25, 2, 2, 660, 661,
	9, 5, 2, 2, 661, 724, 5, 98, 50, 26, 662, 663, 12, 24, 2, 2, 663, 664,
	9, 6, 2, 2, 664, 724, 5, 98, 50, 25, 665, 666, 12, 23, 2, 2, 666, 667,
	9, 7, 2, 2, 667, 724, 5, 98, 50, 24, 668, 669, 12, 22, 2, 2, 669, 670,
	7, 65, 2, 2, 670, 724, 5, 98, 50, 23, 671, 672, 12, 21, 2, 2, 672, 673,
	7, 87, 2, 2, 673, 724, 5, 98, 50, 22, 674, 675, 12, 20, 2, 2, 675, 676,
	9, 8, 2, 2, 676, 724, 5, 98, 50, 21, 677, 678, 12, 19, 2, 2, 678, 679,
	7, 39, 2, 2, 679, 724, 5, 98, 50, 20, 680, 681, 12, 18, 2, 2, 681, 682,
	7, 40, 2, 2, 682, 724, 5, 98, 50, 19, 683, 684, 12, 17, 2, 2, 684, 685,
	7, 41, 2, 2, 685, 724, 5, 98, 50, 18, 686, 687, 12, 16, 2, 2, 687, 688,
	7, 42, 2, 2, 688, 724, 5, 98, 50, 17, 689, 690, 12, 15, 2, 2, 690, 691,
	7, 43, 2, 2, 691, 724, 5, 98, 50, 16, 692, 693, 12, 14, 2, 2, 693, 694,
	7, 15, 2, 2, 694, 695, 5, 98, 50, 2, 695, 696, 7, 16, 2, 2, 696, 697, 5,
	98, 50, 15, 697, 724, 3, 2, 2, 2, 698, 699, 12, 13, 2, 2, 699, 700, 7,
	14, 2, 2, 700, 724, 5, 98, 50, 14, 701, 702, 12, 12, 2, 2, 702, 703, 5,
	104, 53, 2, 703, 704, 5, 98, 50, 13, 704, 724, 3, 2, 2, 2, 705, 706, 12,
	41, 2, 2, 706, 707, 7, 6, 2, 2, 707, 708, 5, 96, 49, 2, 708, 709, 7, 7,
	2, 2, 709, 724, 3, 2, 2, 2, 710, 711, 12, 40, 2, 2, 711, 712, 7, 18, 2,
	2, 712, 724, 5, 110, 56, 2, 713, 714, 12, 39, 2, 2, 714, 724, 5, 92, 47,
	2, 715, 716, 12, 37, 2, 2, 716, 717, 6, 50, 29, 2, 717, 724, 7, 19, 2,
	2, 718, 719, 12, 36, 2, 2, 719, 720, 6, 50, 31, 2, 720, 724, 7, 20, 2,
	2, 721, 722, 12, 11, 2, 2, 722, 724, 7, 107, 2, 2, 723, 656, 3, 2, 2, 2,
	723, 659, 3, 2, 2, 2, 723, 662, 3, 2, 2, 2, 723, 665, 3, 2, 2, 2, 723,
	668, 3, 2, 2, 2, 723, 671, 3, 2, 2, 2, 723, 674, 3, 2, 2, 2, 723, 677,
	3, 2, 2, 2, 723, 680, 3, 2, 2, 2, 723, 683, 3, 2, 2, 2, 723, 686, 3, 2,
	2, 2, 723, 689, 3, 2, 2, 2, 723, 692, 3, 2, 2, 2, 723, 698, 3, 2, 2, 2,
	723, 701, 3, 2, 2, 2, 723, 705, 3, 2, 2, 2, 723, 710, 3, 2, 2, 2, 723,
	713, 3, 2, 2, 2, 723, 715, 3, 2, 2, 2, 723, 718, 3, 2, 2, 2, 723, 721,
	3, 2, 2, 2, 724, 727, 3, 2, 2, 2, 725, 723, 3, 2, 2, 2, 725, 726, 3, 2,
	2, 2, 726, 99, 3, 2, 2, 2, 727, 725, 3, 2, 2, 2, 728, 735, 7, 105, 2, 2,
	729, 731, 7, 8, 2, 2, 730, 732, 5, 70, 36, 2, 731, 730, 3, 2, 2, 2, 731,
	732, 3, 2, 2, 2, 732, 733, 3, 2, 2, 2, 733, 735, 7, 9, 2, 2, 734, 728,
	3, 2, 2, 2, 734, 729, 3, 2, 2, 2, 735, 101, 3, 2, 2, 2, 736, 742, 5, 98,
	50, 2, 737, 738, 7, 10, 2, 2, 738, 739, 5, 76, 39, 2, 739, 740, 7, 11,
	2, 2, 740, 742, 3, 2, 2, 2, 741, 736, 3, 2, 2, 2, 741, 737, 3, 2, 2, 2,
	742, 103, 3, 2, 2, 2, 743, 744, 9, 9, 2, 2, 744, 105, 3, 2, 2, 2, 745,
	752, 7, 56, 2, 2, 746, 752, 7, 57, 2, 2, 747, 752, 7, 106, 2, 2, 748, 752,
	7, 107, 2, 2, 749, 752, 7, 5, 2, 2, 750, 752, 5, 108, 55, 2, 751, 745,
	3, 2, 2, 2, 751, 746, 3, 2, 2, 2, 751, 747, 3, 2, 2, 2, 751, 748, 3, 2,
	2, 2, 751, 749, 3, 2, 2, 2, 751, 750, 3, 2, 2, 2, 752, 107, 3, 2, 2, 2,
	753, 754, 9, 10, 2, 2, 754, 109, 3, 2, 2, 2, 755, 758, 7, 105, 2, 2, 756,
	758, 5, 112, 57, 2, 757, 755, 3, 2, 2, 2, 757, 756, 3, 2, 2, 2, 758, 111,
	3, 2, 2, 2, 759, 763, 5, 114, 58, 2, 760, 763, 7, 56, 2, 2, 761, 763, 7,
	57, 2, 2, 762, 759, 3, 2, 2, 2, 762, 760, 3, 2, 2, 2, 762, 761, 3, 2, 2,
	2, 763, 113, 3, 2, 2, 2, 764, 765, 9, 11, 2, 2, 765, 115, 3, 2, 2, 2, 766,
	767, 7, 105, 2, 2, 767, 768, 6, 59, 33, 2, 768, 769, 5, 90, 46, 2, 769,
	117, 3, 2, 2, 2, 770, 771, 7, 105, 2, 2, 771, 772, 6, 60, 34, 2, 772, 773,
	5, 90, 46, 2, 773, 119, 3, 2, 2, 2, 774, 779, 7, 12, 2, 2, 775, 779, 7,
	2, 2, 3, 776, 779, 6, 61, 35, 2, 777, 779, 6, 61, 36, 2, 778, 774, 3, 2,
	2, 2, 778, 775, 3, 2, 2, 2, 778, 776, 3, 2, 2, 2, 778, 777, 3, 2, 2, 2,
	779, 121, 3, 2, 2, 2, 77, 123, 128, 149, 153, 160, 171, 177, 181, 196,
	215, 219, 223, 233, 237, 248, 261, 267, 274, 281, 288, 306, 310, 312, 319,
	325, 330, 345, 348, 366, 379, 385, 393, 397, 402, 419, 427, 430, 435, 447,
	452, 457, 462, 468, 473, 479, 483, 488, 497, 502, 508, 511, 514, 525, 528,
	531, 562, 567, 575, 580, 583, 595, 601, 605, 614, 620, 654, 723, 725, 731,
	734, 741, 751, 757, 762, 778,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "'['", "']'", "'('", "')'", "'{'", "'}'", "';'", "','",
	"'='", "'?'", "':'", "'...'", "'.'", "'++'", "'--'", "'+'", "'-'", "'~'",
	"'!'", "'*'", "'/'", "'%'", "'>>'", "'<<'", "'>>>'", "'<'", "'>'", "'<='",
	"'>='", "'=='", "'!='", "'==='", "'!=='", "'&'", "'^'", "'|'", "'&&'",
	"'||'", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='", "'>>='", "'>>>='",
	"'&='", "'^='", "'|='", "'=>'", "'null'", "", "", "", "", "", "", "'break'",
	"'do'", "'instanceof'", "'typeof'", "'case'", "'else'", "'new'", "'var'",
	"'catch'", "'finally'", "'return'", "'void'", "'continue'", "'for'", "'switch'",
	"'while'", "'debugger'", "'function'", "'this'", "'with'", "'default'",
	"'if'", "'throw'", "'delete'", "'in'", "'try'", "'class'", "'enum'", "'extends'",
	"'super'", "'const'", "'export'", "'import'", "'implements'", "'let'",
	"'private'", "'public'", "'interface'", "'package'", "'protected'", "'static'",
	"'yield'",
}
var symbolicNames = []string{
	"", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral",
	"OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace",
	"CloseBrace", "SemiColon", "Comma", "Assign", "QuestionMark", "Colon",
	"Ellipsis", "Dot", "PlusPlus", "MinusMinus", "Plus", "Minus", "BitNot",
	"Not", "Multiply", "Divide", "Modulus", "RightShiftArithmetic", "LeftShiftArithmetic",
	"RightShiftLogical", "LessThan", "MoreThan", "LessThanEquals", "GreaterThanEquals",
	"Equals_", "NotEquals", "IdentityEquals", "IdentityNotEquals", "BitAnd",
	"BitXOr", "BitOr", "And", "Or", "MultiplyAssign", "DivideAssign", "ModulusAssign",
	"PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", "RightShiftArithmeticAssign",
	"RightShiftLogicalAssign", "BitAndAssign", "BitXorAssign", "BitOrAssign",
	"ARROW", "NullLiteral", "BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral",
	"OctalIntegerLiteral", "OctalIntegerLiteral2", "BinaryIntegerLiteral",
	"Break", "Do", "Instanceof", "Typeof", "Case", "Else", "New", "Var", "Catch",
	"Finally", "Return", "Void", "Continue", "For", "Switch", "While", "Debugger",
	"Function", "This", "With", "Default", "If", "Throw", "Delete", "In", "Try",
	"Class", "Enum", "Extends", "Super", "Const", "Export", "Import", "Implements",
	"Let", "Private", "Public", "Interface", "Package", "Protected", "Static",
	"Yield", "Identifier", "StringLiteral", "TemplateStringLiteral", "WhiteSpaces",
	"LineTerminator", "HtmlComment", "CDataComment", "UnexpectedCharacter",
}

var ruleNames = []string{
	"program", "sourceElement", "statement", "block", "statementList", "variableStatement",
	"variableDeclarationList", "variableDeclaration", "emptyStatement_", "expressionStatement",
	"ifStatement", "iterationStatement", "varModifier", "continueStatement",
	"breakStatement", "returnStatement", "withStatement", "switchStatement",
	"caseBlock", "caseClauses", "caseClause", "defaultClause", "labelledStatement",
	"throwStatement", "tryStatement", "catchProduction", "finallyProduction",
	"debuggerStatement", "functionDeclaration", "classDeclaration", "classTail",
	"classElement", "methodDefinition", "generatorMethod", "formalParameterList",
	"formalParameterArg", "lastFormalParameterArg", "functionBody", "sourceElements",
	"arrayLiteral", "elementList", "lastElement", "objectLiteral", "propertyAssignment",
	"propertyName", "arguments", "lastArgument", "expressionSequence", "singleExpression",
	"arrowFunctionParameters", "arrowFunctionBody", "assignmentOperator", "literal",
	"numericLiteral", "identifierName", "reservedWord", "keyword", "getter",
	"setter", "eos",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type JavaScriptParser struct {
	JavaScriptBaseParser
}

func NewJavaScriptParser(input antlr.TokenStream) *JavaScriptParser {
	this := new(JavaScriptParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "JavaScriptParser.g4"

	return this
}

// JavaScriptParser tokens.
const (
	JavaScriptParserEOF                        = antlr.TokenEOF
	JavaScriptParserMultiLineComment           = 1
	JavaScriptParserSingleLineComment          = 2
	JavaScriptParserRegularExpressionLiteral   = 3
	JavaScriptParserOpenBracket                = 4
	JavaScriptParserCloseBracket               = 5
	JavaScriptParserOpenParen                  = 6
	JavaScriptParserCloseParen                 = 7
	JavaScriptParserOpenBrace                  = 8
	JavaScriptParserCloseBrace                 = 9
	JavaScriptParserSemiColon                  = 10
	JavaScriptParserComma                      = 11
	JavaScriptParserAssign                     = 12
	JavaScriptParserQuestionMark               = 13
	JavaScriptParserColon                      = 14
	JavaScriptParserEllipsis                   = 15
	JavaScriptParserDot                        = 16
	JavaScriptParserPlusPlus                   = 17
	JavaScriptParserMinusMinus                 = 18
	JavaScriptParserPlus                       = 19
	JavaScriptParserMinus                      = 20
	JavaScriptParserBitNot                     = 21
	JavaScriptParserNot                        = 22
	JavaScriptParserMultiply                   = 23
	JavaScriptParserDivide                     = 24
	JavaScriptParserModulus                    = 25
	JavaScriptParserRightShiftArithmetic       = 26
	JavaScriptParserLeftShiftArithmetic        = 27
	JavaScriptParserRightShiftLogical          = 28
	JavaScriptParserLessThan                   = 29
	JavaScriptParserMoreThan                   = 30
	JavaScriptParserLessThanEquals             = 31
	JavaScriptParserGreaterThanEquals          = 32
	JavaScriptParserEquals_                    = 33
	JavaScriptParserNotEquals                  = 34
	JavaScriptParserIdentityEquals             = 35
	JavaScriptParserIdentityNotEquals          = 36
	JavaScriptParserBitAnd                     = 37
	JavaScriptParserBitXOr                     = 38
	JavaScriptParserBitOr                      = 39
	JavaScriptParserAnd                        = 40
	JavaScriptParserOr                         = 41
	JavaScriptParserMultiplyAssign             = 42
	JavaScriptParserDivideAssign               = 43
	JavaScriptParserModulusAssign              = 44
	JavaScriptParserPlusAssign                 = 45
	JavaScriptParserMinusAssign                = 46
	JavaScriptParserLeftShiftArithmeticAssign  = 47
	JavaScriptParserRightShiftArithmeticAssign = 48
	JavaScriptParserRightShiftLogicalAssign    = 49
	JavaScriptParserBitAndAssign               = 50
	JavaScriptParserBitXorAssign               = 51
	JavaScriptParserBitOrAssign                = 52
	JavaScriptParserARROW                      = 53
	JavaScriptParserNullLiteral                = 54
	JavaScriptParserBooleanLiteral             = 55
	JavaScriptParserDecimalLiteral             = 56
	JavaScriptParserHexIntegerLiteral          = 57
	JavaScriptParserOctalIntegerLiteral        = 58
	JavaScriptParserOctalIntegerLiteral2       = 59
	JavaScriptParserBinaryIntegerLiteral       = 60
	JavaScriptParserBreak                      = 61
	JavaScriptParserDo                         = 62
	JavaScriptParserInstanceof                 = 63
	JavaScriptParserTypeof                     = 64
	JavaScriptParserCase                       = 65
	JavaScriptParserElse                       = 66
	JavaScriptParserNew                        = 67
	JavaScriptParserVar                        = 68
	JavaScriptParserCatch                      = 69
	JavaScriptParserFinally                    = 70
	JavaScriptParserReturn                     = 71
	JavaScriptParserVoid                       = 72
	JavaScriptParserContinue                   = 73
	JavaScriptParserFor                        = 74
	JavaScriptParserSwitch                     = 75
	JavaScriptParserWhile                      = 76
	JavaScriptParserDebugger                   = 77
	JavaScriptParserFunction                   = 78
	JavaScriptParserThis                       = 79
	JavaScriptParserWith                       = 80
	JavaScriptParserDefault                    = 81
	JavaScriptParserIf                         = 82
	JavaScriptParserThrow                      = 83
	JavaScriptParserDelete                     = 84
	JavaScriptParserIn                         = 85
	JavaScriptParserTry                        = 86
	JavaScriptParserClass                      = 87
	JavaScriptParserEnum                       = 88
	JavaScriptParserExtends                    = 89
	JavaScriptParserSuper                      = 90
	JavaScriptParserConst                      = 91
	JavaScriptParserExport                     = 92
	JavaScriptParserImport                     = 93
	JavaScriptParserImplements                 = 94
	JavaScriptParserLet                        = 95
	JavaScriptParserPrivate                    = 96
	JavaScriptParserPublic                     = 97
	JavaScriptParserInterface                  = 98
	JavaScriptParserPackage                    = 99
	JavaScriptParserProtected                  = 100
	JavaScriptParserStatic                     = 101
	JavaScriptParserYield                      = 102
	JavaScriptParserIdentifier                 = 103
	JavaScriptParserStringLiteral              = 104
	JavaScriptParserTemplateStringLiteral      = 105
	JavaScriptParserWhiteSpaces                = 106
	JavaScriptParserLineTerminator             = 107
	JavaScriptParserHtmlComment                = 108
	JavaScriptParserCDataComment               = 109
	JavaScriptParserUnexpectedCharacter        = 110
)

// JavaScriptParser rules.
const (
	JavaScriptParserRULE_program                 = 0
	JavaScriptParserRULE_sourceElement           = 1
	JavaScriptParserRULE_statement               = 2
	JavaScriptParserRULE_block                   = 3
	JavaScriptParserRULE_statementList           = 4
	JavaScriptParserRULE_variableStatement       = 5
	JavaScriptParserRULE_variableDeclarationList = 6
	JavaScriptParserRULE_variableDeclaration     = 7
	JavaScriptParserRULE_emptyStatement_         = 8
	JavaScriptParserRULE_expressionStatement     = 9
	JavaScriptParserRULE_ifStatement             = 10
	JavaScriptParserRULE_iterationStatement      = 11
	JavaScriptParserRULE_varModifier             = 12
	JavaScriptParserRULE_continueStatement       = 13
	JavaScriptParserRULE_breakStatement          = 14
	JavaScriptParserRULE_returnStatement         = 15
	JavaScriptParserRULE_withStatement           = 16
	JavaScriptParserRULE_switchStatement         = 17
	JavaScriptParserRULE_caseBlock               = 18
	JavaScriptParserRULE_caseClauses             = 19
	JavaScriptParserRULE_caseClause              = 20
	JavaScriptParserRULE_defaultClause           = 21
	JavaScriptParserRULE_labelledStatement       = 22
	JavaScriptParserRULE_throwStatement          = 23
	JavaScriptParserRULE_tryStatement            = 24
	JavaScriptParserRULE_catchProduction         = 25
	JavaScriptParserRULE_finallyProduction       = 26
	JavaScriptParserRULE_debuggerStatement       = 27
	JavaScriptParserRULE_functionDeclaration     = 28
	JavaScriptParserRULE_classDeclaration        = 29
	JavaScriptParserRULE_classTail               = 30
	JavaScriptParserRULE_classElement            = 31
	JavaScriptParserRULE_methodDefinition        = 32
	JavaScriptParserRULE_generatorMethod         = 33
	JavaScriptParserRULE_formalParameterList     = 34
	JavaScriptParserRULE_formalParameterArg      = 35
	JavaScriptParserRULE_lastFormalParameterArg  = 36
	JavaScriptParserRULE_functionBody            = 37
	JavaScriptParserRULE_sourceElements          = 38
	JavaScriptParserRULE_arrayLiteral            = 39
	JavaScriptParserRULE_elementList             = 40
	JavaScriptParserRULE_lastElement             = 41
	JavaScriptParserRULE_objectLiteral           = 42
	JavaScriptParserRULE_propertyAssignment      = 43
	JavaScriptParserRULE_propertyName            = 44
	JavaScriptParserRULE_arguments               = 45
	JavaScriptParserRULE_lastArgument            = 46
	JavaScriptParserRULE_expressionSequence      = 47
	JavaScriptParserRULE_singleExpression        = 48
	JavaScriptParserRULE_arrowFunctionParameters = 49
	JavaScriptParserRULE_arrowFunctionBody       = 50
	JavaScriptParserRULE_assignmentOperator      = 51
	JavaScriptParserRULE_literal                 = 52
	JavaScriptParserRULE_numericLiteral          = 53
	JavaScriptParserRULE_identifierName          = 54
	JavaScriptParserRULE_reservedWord            = 55
	JavaScriptParserRULE_keyword                 = 56
	JavaScriptParserRULE_getter                  = 57
	JavaScriptParserRULE_setter                  = 58
	JavaScriptParserRULE_eos                     = 59
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEOF, 0)
}

func (s *ProgramContext) SourceElements() ISourceElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, JavaScriptParserRULE_program)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(121)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(120)
			p.SourceElements()
		}

	}
	{
		p.SetState(123)
		p.Match(JavaScriptParserEOF)
	}

	return localctx
}

// ISourceElementContext is an interface to support dynamic dispatch.
type ISourceElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceElementContext differentiates from other interfaces.
	IsSourceElementContext()
}

type SourceElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementContext() *SourceElementContext {
	var p = new(SourceElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_sourceElement
	return p
}

func (*SourceElementContext) IsSourceElementContext() {}

func NewSourceElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementContext {
	var p = new(SourceElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_sourceElement

	return p
}

func (s *SourceElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SourceElementContext) Export() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExport, 0)
}

func (s *SourceElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSourceElement(s)
	}
}

func (s *SourceElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSourceElement(s)
	}
}

func (s *SourceElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSourceElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) SourceElement() (localctx ISourceElementContext) {
	localctx = NewSourceElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, JavaScriptParserRULE_sourceElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(126)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(125)
			p.Match(JavaScriptParserExport)
		}

	}
	{
		p.SetState(128)
		p.Statement()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) VariableStatement() IVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *StatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmptyStatement_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIterationStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreakStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) WithStatement() IWithStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StatementContext) LabelledStatement() ILabelledStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelledStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelledStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrowStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) DebuggerStatement() IDebuggerStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDebuggerStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDebuggerStatementContext)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, JavaScriptParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(147)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(130)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(131)
			p.VariableStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(132)
			p.EmptyStatement_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(133)
			p.ClassDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(134)
			p.ExpressionStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(135)
			p.IfStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(136)
			p.IterationStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(137)
			p.ContinueStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(138)
			p.BreakStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(139)
			p.ReturnStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(140)
			p.WithStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(141)
			p.LabelledStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(142)
			p.SwitchStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(143)
			p.ThrowStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(144)
			p.TryStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(145)
			p.DebuggerStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(146)
			p.FunctionDeclaration()
		}

	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *BlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, JavaScriptParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(149)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(151)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(150)
			p.StatementList()
		}

	}
	{
		p.SetState(153)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_statementList
	return p
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (s *StatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) StatementList() (localctx IStatementListContext) {
	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, JavaScriptParserRULE_statementList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(156)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(155)
				p.Statement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(158)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableStatementContext is an interface to support dynamic dispatch.
type IVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableStatementContext differentiates from other interfaces.
	IsVariableStatementContext()
}

type VariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStatementContext() *VariableStatementContext {
	var p = new(VariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableStatement
	return p
}

func (*VariableStatementContext) IsVariableStatementContext() {}

func NewVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStatementContext {
	var p = new(VariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableStatement

	return p
}

func (s *VariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStatementContext) VarModifier() IVarModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *VariableStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *VariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVariableStatement(s)
	}
}

func (s *VariableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVariableStatement(s)
	}
}

func (s *VariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) VariableStatement() (localctx IVariableStatementContext) {
	localctx = NewVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, JavaScriptParserRULE_variableStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(160)
		p.VarModifier()
	}
	{
		p.SetState(161)
		p.VariableDeclarationList()
	}
	{
		p.SetState(162)
		p.Eos()
	}

	return localctx
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableDeclarationList
	return p
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem())
	var tst = make([]IVariableDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclarationContext)
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *VariableDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVariableDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, JavaScriptParserRULE_variableDeclarationList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(164)
		p.VariableDeclaration()
	}
	p.SetState(169)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(165)
				p.Match(JavaScriptParserComma)
			}
			{
				p.SetState(166)
				p.VariableDeclaration()
			}

		}
		p.SetState(171)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *VariableDeclarationContext) ArrayLiteral() IArrayLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *VariableDeclarationContext) ObjectLiteral() IObjectLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *VariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *VariableDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, JavaScriptParserRULE_variableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(175)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserIdentifier:
		{
			p.SetState(172)
			p.Match(JavaScriptParserIdentifier)
		}

	case JavaScriptParserOpenBracket:
		{
			p.SetState(173)
			p.ArrayLiteral()
		}

	case JavaScriptParserOpenBrace:
		{
			p.SetState(174)
			p.ObjectLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(179)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(177)
			p.Match(JavaScriptParserAssign)
		}
		{
			p.SetState(178)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SemiColon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, JavaScriptParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(181)
		p.Match(JavaScriptParserSemiColon)
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ExpressionStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, JavaScriptParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(183)

	if !(p.notOpenBraceAndNotFunction()) {
		panic(antlr.NewFailedPredicateException(p, "p.notOpenBraceAndNotFunction()", ""))
	}
	{
		p.SetState(184)
		p.ExpressionSequence()
	}
	{
		p.SetState(185)
		p.Eos()
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIf, 0)
}

func (s *IfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *IfStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *IfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserElse, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, JavaScriptParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(187)
		p.Match(JavaScriptParserIf)
	}
	{
		p.SetState(188)
		p.Match(JavaScriptParserOpenParen)
	}
	{
		p.SetState(189)
		p.ExpressionSequence()
	}
	{
		p.SetState(190)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(191)
		p.Statement()
	}
	p.SetState(194)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(192)
			p.Match(JavaScriptParserElse)
		}
		{
			p.SetState(193)
			p.Statement()
		}

	}

	return localctx
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_iterationStatement
	return p
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) CopyFrom(ctx *IterationStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoStatementContext struct {
	*IterationStatementContext
}

func NewDoStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoStatementContext {
	var p = new(DoStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDo, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *DoStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *DoStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *DoStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *DoStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForVarStatementContext struct {
	*IterationStatementContext
}

func NewForVarStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForVarStatementContext {
	var p = new(ForVarStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForVarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForVarStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForVarStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForVarStatementContext) VarModifier() IVarModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *ForVarStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *ForVarStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserSemiColon)
}

func (s *ForVarStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, i)
}

func (s *ForVarStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForVarStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForVarStatementContext) AllExpressionSequence() []IExpressionSequenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem())
	var tst = make([]IExpressionSequenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionSequenceContext)
		}
	}

	return tst
}

func (s *ForVarStatementContext) ExpressionSequence(i int) IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForVarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterForVarStatement(s)
	}
}

func (s *ForVarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitForVarStatement(s)
	}
}

func (s *ForVarStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForVarStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForVarInStatementContext struct {
	*IterationStatementContext
}

func NewForVarInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForVarInStatementContext {
	var p = new(ForVarInStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForVarInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForVarInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForVarInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForVarInStatementContext) VarModifier() IVarModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *ForVarInStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForVarInStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForVarInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForVarInStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForVarInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *ForVarInStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ForVarInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterForVarInStatement(s)
	}
}

func (s *ForVarInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitForVarInStatement(s)
	}
}

func (s *ForVarInStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForVarInStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhileStatementContext struct {
	*IterationStatementContext
}

func NewWhileStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *WhileStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *WhileStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WhileStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForStatementContext struct {
	*IterationStatementContext
}

func NewForStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStatementContext {
	var p = new(ForStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, i)
}

func (s *ForStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) AllExpressionSequence() []IExpressionSequenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem())
	var tst = make([]IExpressionSequenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionSequenceContext)
		}
	}

	return tst
}

func (s *ForStatementContext) ExpressionSequence(i int) IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForInStatementContext struct {
	*IterationStatementContext
}

func NewForInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInStatementContext {
	var p = new(ForInStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *ForInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ForInStatementContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForInStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ForInStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *ForInStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ForInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterForInStatement(s)
	}
}

func (s *ForInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitForInStatement(s)
	}
}

func (s *ForInStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitForInStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) IterationStatement() (localctx IIterationStatementContext) {
	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, JavaScriptParserRULE_iterationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDoStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(196)
			p.Match(JavaScriptParserDo)
		}
		{
			p.SetState(197)
			p.Statement()
		}
		{
			p.SetState(198)
			p.Match(JavaScriptParserWhile)
		}
		{
			p.SetState(199)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(200)
			p.ExpressionSequence()
		}
		{
			p.SetState(201)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(202)
			p.Eos()
		}

	case 2:
		localctx = NewWhileStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(204)
			p.Match(JavaScriptParserWhile)
		}
		{
			p.SetState(205)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(206)
			p.ExpressionSequence()
		}
		{
			p.SetState(207)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(208)
			p.Statement()
		}

	case 3:
		localctx = NewForStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(210)
			p.Match(JavaScriptParserFor)
		}
		{
			p.SetState(211)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserRegularExpressionLiteral)|(1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenParen)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserPlusPlus)|(1<<JavaScriptParserMinusMinus)|(1<<JavaScriptParserPlus)|(1<<JavaScriptParserMinus)|(1<<JavaScriptParserBitNot)|(1<<JavaScriptParserNot))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(JavaScriptParserNullLiteral-54))|(1<<(JavaScriptParserBooleanLiteral-54))|(1<<(JavaScriptParserDecimalLiteral-54))|(1<<(JavaScriptParserHexIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral2-54))|(1<<(JavaScriptParserBinaryIntegerLiteral-54))|(1<<(JavaScriptParserTypeof-54))|(1<<(JavaScriptParserNew-54))|(1<<(JavaScriptParserVoid-54))|(1<<(JavaScriptParserFunction-54))|(1<<(JavaScriptParserThis-54))|(1<<(JavaScriptParserDelete-54)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(JavaScriptParserClass-87))|(1<<(JavaScriptParserSuper-87))|(1<<(JavaScriptParserIdentifier-87))|(1<<(JavaScriptParserStringLiteral-87))|(1<<(JavaScriptParserTemplateStringLiteral-87)))) != 0) {
			{
				p.SetState(212)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(215)
			p.Match(JavaScriptParserSemiColon)
		}
		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserRegularExpressionLiteral)|(1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenParen)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserPlusPlus)|(1<<JavaScriptParserMinusMinus)|(1<<JavaScriptParserPlus)|(1<<JavaScriptParserMinus)|(1<<JavaScriptParserBitNot)|(1<<JavaScriptParserNot))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(JavaScriptParserNullLiteral-54))|(1<<(JavaScriptParserBooleanLiteral-54))|(1<<(JavaScriptParserDecimalLiteral-54))|(1<<(JavaScriptParserHexIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral2-54))|(1<<(JavaScriptParserBinaryIntegerLiteral-54))|(1<<(JavaScriptParserTypeof-54))|(1<<(JavaScriptParserNew-54))|(1<<(JavaScriptParserVoid-54))|(1<<(JavaScriptParserFunction-54))|(1<<(JavaScriptParserThis-54))|(1<<(JavaScriptParserDelete-54)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(JavaScriptParserClass-87))|(1<<(JavaScriptParserSuper-87))|(1<<(JavaScriptParserIdentifier-87))|(1<<(JavaScriptParserStringLiteral-87))|(1<<(JavaScriptParserTemplateStringLiteral-87)))) != 0) {
			{
				p.SetState(216)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(219)
			p.Match(JavaScriptParserSemiColon)
		}
		p.SetState(221)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserRegularExpressionLiteral)|(1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenParen)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserPlusPlus)|(1<<JavaScriptParserMinusMinus)|(1<<JavaScriptParserPlus)|(1<<JavaScriptParserMinus)|(1<<JavaScriptParserBitNot)|(1<<JavaScriptParserNot))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(JavaScriptParserNullLiteral-54))|(1<<(JavaScriptParserBooleanLiteral-54))|(1<<(JavaScriptParserDecimalLiteral-54))|(1<<(JavaScriptParserHexIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral2-54))|(1<<(JavaScriptParserBinaryIntegerLiteral-54))|(1<<(JavaScriptParserTypeof-54))|(1<<(JavaScriptParserNew-54))|(1<<(JavaScriptParserVoid-54))|(1<<(JavaScriptParserFunction-54))|(1<<(JavaScriptParserThis-54))|(1<<(JavaScriptParserDelete-54)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(JavaScriptParserClass-87))|(1<<(JavaScriptParserSuper-87))|(1<<(JavaScriptParserIdentifier-87))|(1<<(JavaScriptParserStringLiteral-87))|(1<<(JavaScriptParserTemplateStringLiteral-87)))) != 0) {
			{
				p.SetState(220)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(223)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(224)
			p.Statement()
		}

	case 4:
		localctx = NewForVarStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(225)
			p.Match(JavaScriptParserFor)
		}
		{
			p.SetState(226)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(227)
			p.VarModifier()
		}
		{
			p.SetState(228)
			p.VariableDeclarationList()
		}
		{
			p.SetState(229)
			p.Match(JavaScriptParserSemiColon)
		}
		p.SetState(231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserRegularExpressionLiteral)|(1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenParen)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserPlusPlus)|(1<<JavaScriptParserMinusMinus)|(1<<JavaScriptParserPlus)|(1<<JavaScriptParserMinus)|(1<<JavaScriptParserBitNot)|(1<<JavaScriptParserNot))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(JavaScriptParserNullLiteral-54))|(1<<(JavaScriptParserBooleanLiteral-54))|(1<<(JavaScriptParserDecimalLiteral-54))|(1<<(JavaScriptParserHexIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral2-54))|(1<<(JavaScriptParserBinaryIntegerLiteral-54))|(1<<(JavaScriptParserTypeof-54))|(1<<(JavaScriptParserNew-54))|(1<<(JavaScriptParserVoid-54))|(1<<(JavaScriptParserFunction-54))|(1<<(JavaScriptParserThis-54))|(1<<(JavaScriptParserDelete-54)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(JavaScriptParserClass-87))|(1<<(JavaScriptParserSuper-87))|(1<<(JavaScriptParserIdentifier-87))|(1<<(JavaScriptParserStringLiteral-87))|(1<<(JavaScriptParserTemplateStringLiteral-87)))) != 0) {
			{
				p.SetState(230)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(233)
			p.Match(JavaScriptParserSemiColon)
		}
		p.SetState(235)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserRegularExpressionLiteral)|(1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenParen)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserPlusPlus)|(1<<JavaScriptParserMinusMinus)|(1<<JavaScriptParserPlus)|(1<<JavaScriptParserMinus)|(1<<JavaScriptParserBitNot)|(1<<JavaScriptParserNot))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(JavaScriptParserNullLiteral-54))|(1<<(JavaScriptParserBooleanLiteral-54))|(1<<(JavaScriptParserDecimalLiteral-54))|(1<<(JavaScriptParserHexIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral2-54))|(1<<(JavaScriptParserBinaryIntegerLiteral-54))|(1<<(JavaScriptParserTypeof-54))|(1<<(JavaScriptParserNew-54))|(1<<(JavaScriptParserVoid-54))|(1<<(JavaScriptParserFunction-54))|(1<<(JavaScriptParserThis-54))|(1<<(JavaScriptParserDelete-54)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(JavaScriptParserClass-87))|(1<<(JavaScriptParserSuper-87))|(1<<(JavaScriptParserIdentifier-87))|(1<<(JavaScriptParserStringLiteral-87))|(1<<(JavaScriptParserTemplateStringLiteral-87)))) != 0) {
			{
				p.SetState(234)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(237)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(238)
			p.Statement()
		}

	case 5:
		localctx = NewForInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(240)
			p.Match(JavaScriptParserFor)
		}
		{
			p.SetState(241)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(242)
			p.singleExpression(0)
		}
		p.SetState(246)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaScriptParserIn:
			{
				p.SetState(243)
				p.Match(JavaScriptParserIn)
			}

		case JavaScriptParserIdentifier:
			{
				p.SetState(244)
				p.Match(JavaScriptParserIdentifier)
			}
			p.SetState(245)

			if !(p.p("of")) {
				panic(antlr.NewFailedPredicateException(p, "p.p(\"of\")", ""))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(248)
			p.ExpressionSequence()
		}
		{
			p.SetState(249)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(250)
			p.Statement()
		}

	case 6:
		localctx = NewForVarInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(252)
			p.Match(JavaScriptParserFor)
		}
		{
			p.SetState(253)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(254)
			p.VarModifier()
		}
		{
			p.SetState(255)
			p.VariableDeclaration()
		}
		p.SetState(259)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JavaScriptParserIn:
			{
				p.SetState(256)
				p.Match(JavaScriptParserIn)
			}

		case JavaScriptParserIdentifier:
			{
				p.SetState(257)
				p.Match(JavaScriptParserIdentifier)
			}
			p.SetState(258)

			if !(p.p("of")) {
				panic(antlr.NewFailedPredicateException(p, "p.p(\"of\")", ""))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(261)
			p.ExpressionSequence()
		}
		{
			p.SetState(262)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(263)
			p.Statement()
		}

	}

	return localctx
}

// IVarModifierContext is an interface to support dynamic dispatch.
type IVarModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarModifierContext differentiates from other interfaces.
	IsVarModifierContext()
}

type VarModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarModifierContext() *VarModifierContext {
	var p = new(VarModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_varModifier
	return p
}

func (*VarModifierContext) IsVarModifierContext() {}

func NewVarModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarModifierContext {
	var p = new(VarModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_varModifier

	return p
}

func (s *VarModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarModifierContext) Var() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVar, 0)
}

func (s *VarModifierContext) Let() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLet, 0)
}

func (s *VarModifierContext) Const() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserConst, 0)
}

func (s *VarModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVarModifier(s)
	}
}

func (s *VarModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVarModifier(s)
	}
}

func (s *VarModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVarModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) VarModifier() (localctx IVarModifierContext) {
	localctx = NewVarModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, JavaScriptParserRULE_varModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(267)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(JavaScriptParserVar-68))|(1<<(JavaScriptParserConst-68))|(1<<(JavaScriptParserLet-68)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserContinue, 0)
}

func (s *ContinueStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ContinueStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, JavaScriptParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.Match(JavaScriptParserContinue)
	}
	p.SetState(272)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
		p.SetState(270)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(271)
			p.Match(JavaScriptParserIdentifier)
		}

	}
	{
		p.SetState(274)
		p.Eos()
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBreak, 0)
}

func (s *BreakStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *BreakStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, JavaScriptParserRULE_breakStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(276)
		p.Match(JavaScriptParserBreak)
	}
	p.SetState(279)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		p.SetState(277)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(278)
			p.Match(JavaScriptParserIdentifier)
		}

	}
	{
		p.SetState(281)
		p.Eos()
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserReturn, 0)
}

func (s *ReturnStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ReturnStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, JavaScriptParserRULE_returnStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(JavaScriptParserReturn)
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		p.SetState(284)

		if !(p.notLineTerminator()) {
			panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		}
		{
			p.SetState(285)
			p.ExpressionSequence()
		}

	}
	{
		p.SetState(288)
		p.Eos()
	}

	return localctx
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_withStatement
	return p
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) With() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWith, 0)
}

func (s *WithStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *WithStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WithStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, JavaScriptParserRULE_withStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(290)
		p.Match(JavaScriptParserWith)
	}
	{
		p.SetState(291)
		p.Match(JavaScriptParserOpenParen)
	}
	{
		p.SetState(292)
		p.ExpressionSequence()
	}
	{
		p.SetState(293)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(294)
		p.Statement()
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSwitch, 0)
}

func (s *SwitchStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *SwitchStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *SwitchStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *SwitchStatementContext) CaseBlock() ICaseBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, JavaScriptParserRULE_switchStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(296)
		p.Match(JavaScriptParserSwitch)
	}
	{
		p.SetState(297)
		p.Match(JavaScriptParserOpenParen)
	}
	{
		p.SetState(298)
		p.ExpressionSequence()
	}
	{
		p.SetState(299)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(300)
		p.CaseBlock()
	}

	return localctx
}

// ICaseBlockContext is an interface to support dynamic dispatch.
type ICaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseBlockContext differentiates from other interfaces.
	IsCaseBlockContext()
}

type CaseBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBlockContext() *CaseBlockContext {
	var p = new(CaseBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseBlock
	return p
}

func (*CaseBlockContext) IsCaseBlockContext() {}

func NewCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBlockContext {
	var p = new(CaseBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseBlock

	return p
}

func (s *CaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *CaseBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *CaseBlockContext) AllCaseClauses() []ICaseClausesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseClausesContext)(nil)).Elem())
	var tst = make([]ICaseClausesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseClausesContext)
		}
	}

	return tst
}

func (s *CaseBlockContext) CaseClauses(i int) ICaseClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseClausesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *CaseBlockContext) DefaultClause() IDefaultClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *CaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCaseBlock(s)
	}
}

func (s *CaseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCaseBlock(s)
	}
}

func (s *CaseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCaseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) CaseBlock() (localctx ICaseBlockContext) {
	localctx = NewCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, JavaScriptParserRULE_caseBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserCase {
		{
			p.SetState(303)
			p.CaseClauses()
		}

	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserDefault {
		{
			p.SetState(306)
			p.DefaultClause()
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserCase {
			{
				p.SetState(307)
				p.CaseClauses()
			}

		}

	}
	{
		p.SetState(312)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// ICaseClausesContext is an interface to support dynamic dispatch.
type ICaseClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClausesContext differentiates from other interfaces.
	IsCaseClausesContext()
}

type CaseClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClausesContext() *CaseClausesContext {
	var p = new(CaseClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseClauses
	return p
}

func (*CaseClausesContext) IsCaseClausesContext() {}

func NewCaseClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClausesContext {
	var p = new(CaseClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseClauses

	return p
}

func (s *CaseClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClausesContext) AllCaseClause() []ICaseClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseClauseContext)(nil)).Elem())
	var tst = make([]ICaseClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseClauseContext)
		}
	}

	return tst
}

func (s *CaseClausesContext) CaseClause(i int) ICaseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *CaseClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCaseClauses(s)
	}
}

func (s *CaseClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCaseClauses(s)
	}
}

func (s *CaseClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCaseClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) CaseClauses() (localctx ICaseClausesContext) {
	localctx = NewCaseClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, JavaScriptParserRULE_caseClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == JavaScriptParserCase {
		{
			p.SetState(314)
			p.CaseClause()
		}

		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_caseClause
	return p
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) Case() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCase, 0)
}

func (s *CaseClauseContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *CaseClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *CaseClauseContext) StatementList() IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, JavaScriptParserRULE_caseClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(319)
		p.Match(JavaScriptParserCase)
	}
	{
		p.SetState(320)
		p.ExpressionSequence()
	}
	{
		p.SetState(321)
		p.Match(JavaScriptParserColon)
	}
	p.SetState(323)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(322)
			p.StatementList()
		}

	}

	return localctx
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_defaultClause
	return p
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *DefaultClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *DefaultClauseContext) StatementList() IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, JavaScriptParserRULE_defaultClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(325)
		p.Match(JavaScriptParserDefault)
	}
	{
		p.SetState(326)
		p.Match(JavaScriptParserColon)
	}
	p.SetState(328)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(327)
			p.StatementList()
		}

	}

	return localctx
}

// ILabelledStatementContext is an interface to support dynamic dispatch.
type ILabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelledStatementContext differentiates from other interfaces.
	IsLabelledStatementContext()
}

type LabelledStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelledStatementContext() *LabelledStatementContext {
	var p = new(LabelledStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_labelledStatement
	return p
}

func (*LabelledStatementContext) IsLabelledStatementContext() {}

func NewLabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelledStatementContext {
	var p = new(LabelledStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_labelledStatement

	return p
}

func (s *LabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelledStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *LabelledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *LabelledStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLabelledStatement(s)
	}
}

func (s *LabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLabelledStatement(s)
	}
}

func (s *LabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) LabelledStatement() (localctx ILabelledStatementContext) {
	localctx = NewLabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, JavaScriptParserRULE_labelledStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		p.Match(JavaScriptParserIdentifier)
	}
	{
		p.SetState(331)
		p.Match(JavaScriptParserColon)
	}
	{
		p.SetState(332)
		p.Statement()
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThrow, 0)
}

func (s *ThrowStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ThrowStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, JavaScriptParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.Match(JavaScriptParserThrow)
	}
	p.SetState(335)

	if !(p.notLineTerminator()) {
		panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
	}
	{
		p.SetState(336)
		p.ExpressionSequence()
	}
	{
		p.SetState(337)
		p.Eos()
	}

	return localctx
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Try() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTry, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) CatchProduction() ICatchProductionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchProductionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchProductionContext)
}

func (s *TryStatementContext) FinallyProduction() IFinallyProductionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinallyProductionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinallyProductionContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (s *TryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, JavaScriptParserRULE_tryStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.Match(JavaScriptParserTry)
	}
	{
		p.SetState(340)
		p.Block()
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserCatch:
		{
			p.SetState(341)
			p.CatchProduction()
		}
		p.SetState(343)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(342)
				p.FinallyProduction()
			}

		}

	case JavaScriptParserFinally:
		{
			p.SetState(345)
			p.FinallyProduction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICatchProductionContext is an interface to support dynamic dispatch.
type ICatchProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchProductionContext differentiates from other interfaces.
	IsCatchProductionContext()
}

type CatchProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchProductionContext() *CatchProductionContext {
	var p = new(CatchProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_catchProduction
	return p
}

func (*CatchProductionContext) IsCatchProductionContext() {}

func NewCatchProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchProductionContext {
	var p = new(CatchProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_catchProduction

	return p
}

func (s *CatchProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchProductionContext) Catch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCatch, 0)
}

func (s *CatchProductionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *CatchProductionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *CatchProductionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *CatchProductionContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterCatchProduction(s)
	}
}

func (s *CatchProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitCatchProduction(s)
	}
}

func (s *CatchProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitCatchProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) CatchProduction() (localctx ICatchProductionContext) {
	localctx = NewCatchProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, JavaScriptParserRULE_catchProduction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(348)
		p.Match(JavaScriptParserCatch)
	}
	{
		p.SetState(349)
		p.Match(JavaScriptParserOpenParen)
	}
	{
		p.SetState(350)
		p.Match(JavaScriptParserIdentifier)
	}
	{
		p.SetState(351)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(352)
		p.Block()
	}

	return localctx
}

// IFinallyProductionContext is an interface to support dynamic dispatch.
type IFinallyProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyProductionContext differentiates from other interfaces.
	IsFinallyProductionContext()
}

type FinallyProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyProductionContext() *FinallyProductionContext {
	var p = new(FinallyProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_finallyProduction
	return p
}

func (*FinallyProductionContext) IsFinallyProductionContext() {}

func NewFinallyProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyProductionContext {
	var p = new(FinallyProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_finallyProduction

	return p
}

func (s *FinallyProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyProductionContext) Finally() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFinally, 0)
}

func (s *FinallyProductionContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFinallyProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FinallyProduction() (localctx IFinallyProductionContext) {
	localctx = NewFinallyProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, JavaScriptParserRULE_finallyProduction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(JavaScriptParserFinally)
	}
	{
		p.SetState(355)
		p.Block()
	}

	return localctx
}

// IDebuggerStatementContext is an interface to support dynamic dispatch.
type IDebuggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDebuggerStatementContext differentiates from other interfaces.
	IsDebuggerStatementContext()
}

type DebuggerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDebuggerStatementContext() *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_debuggerStatement
	return p
}

func (*DebuggerStatementContext) IsDebuggerStatementContext() {}

func NewDebuggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_debuggerStatement

	return p
}

func (s *DebuggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DebuggerStatementContext) Debugger() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDebugger, 0)
}

func (s *DebuggerStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DebuggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DebuggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DebuggerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDebuggerStatement(s)
	}
}

func (s *DebuggerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDebuggerStatement(s)
	}
}

func (s *DebuggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDebuggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) DebuggerStatement() (localctx IDebuggerStatementContext) {
	localctx = NewDebuggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, JavaScriptParserRULE_debuggerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(357)
		p.Match(JavaScriptParserDebugger)
	}
	{
		p.SetState(358)
		p.Eos()
	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction, 0)
}

func (s *FunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *FunctionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *FunctionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *FunctionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *FunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, JavaScriptParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		p.Match(JavaScriptParserFunction)
	}
	{
		p.SetState(361)
		p.Match(JavaScriptParserIdentifier)
	}
	{
		p.SetState(362)
		p.Match(JavaScriptParserOpenParen)
	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserEllipsis))) != 0) || _la == JavaScriptParserIdentifier {
		{
			p.SetState(363)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(366)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(367)
		p.Match(JavaScriptParserOpenBrace)
	}
	{
		p.SetState(368)
		p.FunctionBody()
	}
	{
		p.SetState(369)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *ClassDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ClassDeclarationContext) ClassTail() IClassTailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, JavaScriptParserRULE_classDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(JavaScriptParserClass)
	}
	{
		p.SetState(372)
		p.Match(JavaScriptParserIdentifier)
	}
	{
		p.SetState(373)
		p.ClassTail()
	}

	return localctx
}

// IClassTailContext is an interface to support dynamic dispatch.
type IClassTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTailContext differentiates from other interfaces.
	IsClassTailContext()
}

type ClassTailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTailContext() *ClassTailContext {
	var p = new(ClassTailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classTail
	return p
}

func (*ClassTailContext) IsClassTailContext() {}

func NewClassTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTailContext {
	var p = new(ClassTailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classTail

	return p
}

func (s *ClassTailContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTailContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ClassTailContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ClassTailContext) Extends() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExtends, 0)
}

func (s *ClassTailContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ClassTailContext) AllClassElement() []IClassElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassElementContext)(nil)).Elem())
	var tst = make([]IClassElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassElementContext)
		}
	}

	return tst
}

func (s *ClassTailContext) ClassElement(i int) IClassElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassElementContext)
}

func (s *ClassTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterClassTail(s)
	}
}

func (s *ClassTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitClassTail(s)
	}
}

func (s *ClassTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ClassTail() (localctx IClassTailContext) {
	localctx = NewClassTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, JavaScriptParserRULE_classTail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserExtends {
		{
			p.SetState(375)
			p.Match(JavaScriptParserExtends)
		}
		{
			p.SetState(376)
			p.singleExpression(0)
		}

	}
	{
		p.SetState(379)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(380)
				p.ClassElement()
			}

		}
		p.SetState(385)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}
	{
		p.SetState(386)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IClassElementContext is an interface to support dynamic dispatch.
type IClassElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassElementContext differentiates from other interfaces.
	IsClassElementContext()
}

type ClassElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassElementContext() *ClassElementContext {
	var p = new(ClassElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_classElement
	return p
}

func (*ClassElementContext) IsClassElementContext() {}

func NewClassElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassElementContext {
	var p = new(ClassElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_classElement

	return p
}

func (s *ClassElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassElementContext) MethodDefinition() IMethodDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDefinitionContext)
}

func (s *ClassElementContext) Static() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStatic, 0)
}

func (s *ClassElementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ClassElementContext) EmptyStatement_() IEmptyStatement_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmptyStatement_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *ClassElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterClassElement(s)
	}
}

func (s *ClassElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitClassElement(s)
	}
}

func (s *ClassElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ClassElement() (localctx IClassElementContext) {
	localctx = NewClassElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, JavaScriptParserRULE_classElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(391)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(388)
				p.Match(JavaScriptParserStatic)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 2 {
			p.SetState(389)

			if !(p.n("static")) {
				panic(antlr.NewFailedPredicateException(p, "n(\"static\")", ""))
			}
			{
				p.SetState(390)
				p.Match(JavaScriptParserIdentifier)
			}

		}
		{
			p.SetState(393)
			p.MethodDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(394)
			p.EmptyStatement_()
		}

	}

	return localctx
}

// IMethodDefinitionContext is an interface to support dynamic dispatch.
type IMethodDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDefinitionContext differentiates from other interfaces.
	IsMethodDefinitionContext()
}

type MethodDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDefinitionContext() *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_methodDefinition
	return p
}

func (*MethodDefinitionContext) IsMethodDefinitionContext() {}

func NewMethodDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_methodDefinition

	return p
}

func (s *MethodDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDefinitionContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *MethodDefinitionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *MethodDefinitionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *MethodDefinitionContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *MethodDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *MethodDefinitionContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *MethodDefinitionContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *MethodDefinitionContext) Getter() IGetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *MethodDefinitionContext) Setter() ISetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *MethodDefinitionContext) GeneratorMethod() IGeneratorMethodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneratorMethodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneratorMethodContext)
}

func (s *MethodDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMethodDefinition(s)
	}
}

func (s *MethodDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMethodDefinition(s)
	}
}

func (s *MethodDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMethodDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) MethodDefinition() (localctx IMethodDefinitionContext) {
	localctx = NewMethodDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, JavaScriptParserRULE_methodDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(397)
			p.PropertyName()
		}
		{
			p.SetState(398)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserEllipsis))) != 0) || _la == JavaScriptParserIdentifier {
			{
				p.SetState(399)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(402)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(403)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(404)
			p.FunctionBody()
		}
		{
			p.SetState(405)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(407)
			p.Getter()
		}
		{
			p.SetState(408)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(409)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(410)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(411)
			p.FunctionBody()
		}
		{
			p.SetState(412)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(414)
			p.Setter()
		}
		{
			p.SetState(415)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserEllipsis))) != 0) || _la == JavaScriptParserIdentifier {
			{
				p.SetState(416)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(419)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(420)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(421)
			p.FunctionBody()
		}
		{
			p.SetState(422)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(424)
			p.GeneratorMethod()
		}

	}

	return localctx
}

// IGeneratorMethodContext is an interface to support dynamic dispatch.
type IGeneratorMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratorMethodContext differentiates from other interfaces.
	IsGeneratorMethodContext()
}

type GeneratorMethodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorMethodContext() *GeneratorMethodContext {
	var p = new(GeneratorMethodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_generatorMethod
	return p
}

func (*GeneratorMethodContext) IsGeneratorMethodContext() {}

func NewGeneratorMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorMethodContext {
	var p = new(GeneratorMethodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_generatorMethod

	return p
}

func (s *GeneratorMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorMethodContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *GeneratorMethodContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *GeneratorMethodContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *GeneratorMethodContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *GeneratorMethodContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GeneratorMethodContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *GeneratorMethodContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *GeneratorMethodContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *GeneratorMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterGeneratorMethod(s)
	}
}

func (s *GeneratorMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitGeneratorMethod(s)
	}
}

func (s *GeneratorMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitGeneratorMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) GeneratorMethod() (localctx IGeneratorMethodContext) {
	localctx = NewGeneratorMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, JavaScriptParserRULE_generatorMethod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserMultiply {
		{
			p.SetState(427)
			p.Match(JavaScriptParserMultiply)
		}

	}
	{
		p.SetState(430)
		p.Match(JavaScriptParserIdentifier)
	}
	{
		p.SetState(431)
		p.Match(JavaScriptParserOpenParen)
	}
	p.SetState(433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserEllipsis))) != 0) || _la == JavaScriptParserIdentifier {
		{
			p.SetState(432)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(435)
		p.Match(JavaScriptParserCloseParen)
	}
	{
		p.SetState(436)
		p.Match(JavaScriptParserOpenBrace)
	}
	{
		p.SetState(437)
		p.FunctionBody()
	}
	{
		p.SetState(438)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameterArg() []IFormalParameterArgContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFormalParameterArgContext)(nil)).Elem())
	var tst = make([]IFormalParameterArgContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFormalParameterArgContext)
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterArg(i int) IFormalParameterArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterArgContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *FormalParameterListContext) LastFormalParameterArg() ILastFormalParameterArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILastFormalParameterArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterArgContext)
}

func (s *FormalParameterListContext) ArrayLiteral() IArrayLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *FormalParameterListContext) ObjectLiteral() IObjectLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, JavaScriptParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(440)
			p.FormalParameterArg()
		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(441)
					p.Match(JavaScriptParserComma)
				}
				{
					p.SetState(442)
					p.FormalParameterArg()
				}

			}
			p.SetState(447)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext())
		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(448)
				p.Match(JavaScriptParserComma)
			}
			{
				p.SetState(449)
				p.LastFormalParameterArg()
			}

		}

	case JavaScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(452)
			p.LastFormalParameterArg()
		}

	case JavaScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(453)
			p.ArrayLiteral()
		}

	case JavaScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(454)
			p.ObjectLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFormalParameterArgContext is an interface to support dynamic dispatch.
type IFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterArgContext differentiates from other interfaces.
	IsFormalParameterArgContext()
}

type FormalParameterArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterArgContext() *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_formalParameterArg
	return p
}

func (*FormalParameterArgContext) IsFormalParameterArgContext() {}

func NewFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_formalParameterArg

	return p
}

func (s *FormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterArgContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *FormalParameterArgContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *FormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *FormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FormalParameterArg() (localctx IFormalParameterArgContext) {
	localctx = NewFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, JavaScriptParserRULE_formalParameterArg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(JavaScriptParserIdentifier)
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserAssign {
		{
			p.SetState(458)
			p.Match(JavaScriptParserAssign)
		}
		{
			p.SetState(459)
			p.singleExpression(0)
		}

	}

	return localctx
}

// ILastFormalParameterArgContext is an interface to support dynamic dispatch.
type ILastFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastFormalParameterArgContext differentiates from other interfaces.
	IsLastFormalParameterArgContext()
}

type LastFormalParameterArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterArgContext() *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_lastFormalParameterArg
	return p
}

func (*LastFormalParameterArgContext) IsLastFormalParameterArgContext() {}

func NewLastFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_lastFormalParameterArg

	return p
}

func (s *LastFormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterArgContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *LastFormalParameterArgContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *LastFormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLastFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) LastFormalParameterArg() (localctx ILastFormalParameterArgContext) {
	localctx = NewLastFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, JavaScriptParserRULE_lastFormalParameterArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Match(JavaScriptParserEllipsis)
	}
	{
		p.SetState(463)
		p.Match(JavaScriptParserIdentifier)
	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) SourceElements() ISourceElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, JavaScriptParserRULE_functionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(466)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(465)
			p.SourceElements()
		}

	}

	return localctx
}

// ISourceElementsContext is an interface to support dynamic dispatch.
type ISourceElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceElementsContext differentiates from other interfaces.
	IsSourceElementsContext()
}

type SourceElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementsContext() *SourceElementsContext {
	var p = new(SourceElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_sourceElements
	return p
}

func (*SourceElementsContext) IsSourceElementsContext() {}

func NewSourceElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementsContext {
	var p = new(SourceElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_sourceElements

	return p
}

func (s *SourceElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementsContext) AllSourceElement() []ISourceElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISourceElementContext)(nil)).Elem())
	var tst = make([]ISourceElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISourceElementContext)
		}
	}

	return tst
}

func (s *SourceElementsContext) SourceElement(i int) ISourceElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISourceElementContext)
}

func (s *SourceElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSourceElements(s)
	}
}

func (s *SourceElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSourceElements(s)
	}
}

func (s *SourceElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSourceElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) SourceElements() (localctx ISourceElementsContext) {
	localctx = NewSourceElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, JavaScriptParserRULE_sourceElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(468)
				p.SourceElement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrayLiteral
	return p
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *ArrayLiteralContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *ArrayLiteralContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ArrayLiteralContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ArrayLiteralContext) ElementList() IElementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, JavaScriptParserRULE_arrayLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(473)
		p.Match(JavaScriptParserOpenBracket)
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(474)
				p.Match(JavaScriptParserComma)
			}

		}
		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())
	}
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserRegularExpressionLiteral)|(1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenParen)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserEllipsis)|(1<<JavaScriptParserPlusPlus)|(1<<JavaScriptParserMinusMinus)|(1<<JavaScriptParserPlus)|(1<<JavaScriptParserMinus)|(1<<JavaScriptParserBitNot)|(1<<JavaScriptParserNot))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(JavaScriptParserNullLiteral-54))|(1<<(JavaScriptParserBooleanLiteral-54))|(1<<(JavaScriptParserDecimalLiteral-54))|(1<<(JavaScriptParserHexIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral2-54))|(1<<(JavaScriptParserBinaryIntegerLiteral-54))|(1<<(JavaScriptParserTypeof-54))|(1<<(JavaScriptParserNew-54))|(1<<(JavaScriptParserVoid-54))|(1<<(JavaScriptParserFunction-54))|(1<<(JavaScriptParserThis-54))|(1<<(JavaScriptParserDelete-54)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(JavaScriptParserClass-87))|(1<<(JavaScriptParserSuper-87))|(1<<(JavaScriptParserIdentifier-87))|(1<<(JavaScriptParserStringLiteral-87))|(1<<(JavaScriptParserTemplateStringLiteral-87)))) != 0) {
		{
			p.SetState(480)
			p.ElementList()
		}

	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JavaScriptParserComma {
		{
			p.SetState(483)
			p.Match(JavaScriptParserComma)
		}

		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(489)
		p.Match(JavaScriptParserCloseBracket)
	}

	return localctx
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_elementList
	return p
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *ElementListContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ElementListContext) LastElement() ILastElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILastElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILastElementContext)
}

func (s *ElementListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ElementListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, JavaScriptParserRULE_elementList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(512)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserRegularExpressionLiteral, JavaScriptParserOpenBracket, JavaScriptParserOpenParen, JavaScriptParserOpenBrace, JavaScriptParserPlusPlus, JavaScriptParserMinusMinus, JavaScriptParserPlus, JavaScriptParserMinus, JavaScriptParserBitNot, JavaScriptParserNot, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral, JavaScriptParserTypeof, JavaScriptParserNew, JavaScriptParserVoid, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserDelete, JavaScriptParserClass, JavaScriptParserSuper, JavaScriptParserIdentifier, JavaScriptParserStringLiteral, JavaScriptParserTemplateStringLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(491)
			p.singleExpression(0)
		}
		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(493)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == JavaScriptParserComma {
					{
						p.SetState(492)
						p.Match(JavaScriptParserComma)
					}

					p.SetState(495)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(497)
					p.singleExpression(0)
				}

			}
			p.SetState(502)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
		}
		p.SetState(509)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
			p.SetState(504)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == JavaScriptParserComma {
				{
					p.SetState(503)
					p.Match(JavaScriptParserComma)
				}

				p.SetState(506)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(508)
				p.LastElement()
			}

		}

	case JavaScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(511)
			p.LastElement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILastElementContext is an interface to support dynamic dispatch.
type ILastElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastElementContext differentiates from other interfaces.
	IsLastElementContext()
}

type LastElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastElementContext() *LastElementContext {
	var p = new(LastElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_lastElement
	return p
}

func (*LastElementContext) IsLastElementContext() {}

func NewLastElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastElementContext {
	var p = new(LastElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_lastElement

	return p
}

func (s *LastElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LastElementContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *LastElementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *LastElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLastElement(s)
	}
}

func (s *LastElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLastElement(s)
	}
}

func (s *LastElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLastElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) LastElement() (localctx ILastElementContext) {
	localctx = NewLastElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, JavaScriptParserRULE_lastElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(514)
		p.Match(JavaScriptParserEllipsis)
	}
	{
		p.SetState(515)
		p.Match(JavaScriptParserIdentifier)
	}

	return localctx
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_objectLiteral
	return p
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ObjectLiteralContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ObjectLiteralContext) AllPropertyAssignment() []IPropertyAssignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyAssignmentContext)(nil)).Elem())
	var tst = make([]IPropertyAssignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyAssignmentContext)
		}
	}

	return tst
}

func (s *ObjectLiteralContext) PropertyAssignment(i int) IPropertyAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyAssignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentContext)
}

func (s *ObjectLiteralContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ObjectLiteralContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, JavaScriptParserRULE_objectLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		p.Match(JavaScriptParserOpenBrace)
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserOpenBracket || _la == JavaScriptParserMultiply || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(JavaScriptParserNullLiteral-54))|(1<<(JavaScriptParserBooleanLiteral-54))|(1<<(JavaScriptParserDecimalLiteral-54))|(1<<(JavaScriptParserHexIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral-54))|(1<<(JavaScriptParserOctalIntegerLiteral2-54))|(1<<(JavaScriptParserBinaryIntegerLiteral-54))|(1<<(JavaScriptParserBreak-54))|(1<<(JavaScriptParserDo-54))|(1<<(JavaScriptParserInstanceof-54))|(1<<(JavaScriptParserTypeof-54))|(1<<(JavaScriptParserCase-54))|(1<<(JavaScriptParserElse-54))|(1<<(JavaScriptParserNew-54))|(1<<(JavaScriptParserVar-54))|(1<<(JavaScriptParserCatch-54))|(1<<(JavaScriptParserFinally-54))|(1<<(JavaScriptParserReturn-54))|(1<<(JavaScriptParserVoid-54))|(1<<(JavaScriptParserContinue-54))|(1<<(JavaScriptParserFor-54))|(1<<(JavaScriptParserSwitch-54))|(1<<(JavaScriptParserWhile-54))|(1<<(JavaScriptParserDebugger-54))|(1<<(JavaScriptParserFunction-54))|(1<<(JavaScriptParserThis-54))|(1<<(JavaScriptParserWith-54))|(1<<(JavaScriptParserDefault-54))|(1<<(JavaScriptParserIf-54))|(1<<(JavaScriptParserThrow-54))|(1<<(JavaScriptParserDelete-54))|(1<<(JavaScriptParserIn-54)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(JavaScriptParserTry-86))|(1<<(JavaScriptParserClass-86))|(1<<(JavaScriptParserEnum-86))|(1<<(JavaScriptParserExtends-86))|(1<<(JavaScriptParserSuper-86))|(1<<(JavaScriptParserConst-86))|(1<<(JavaScriptParserExport-86))|(1<<(JavaScriptParserImport-86))|(1<<(JavaScriptParserImplements-86))|(1<<(JavaScriptParserLet-86))|(1<<(JavaScriptParserPrivate-86))|(1<<(JavaScriptParserPublic-86))|(1<<(JavaScriptParserInterface-86))|(1<<(JavaScriptParserPackage-86))|(1<<(JavaScriptParserProtected-86))|(1<<(JavaScriptParserStatic-86))|(1<<(JavaScriptParserYield-86))|(1<<(JavaScriptParserIdentifier-86))|(1<<(JavaScriptParserStringLiteral-86)))) != 0) {
		{
			p.SetState(518)
			p.PropertyAssignment()
		}
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(519)
					p.Match(JavaScriptParserComma)
				}
				{
					p.SetState(520)
					p.PropertyAssignment()
				}

			}
			p.SetState(525)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
		}

	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JavaScriptParserComma {
		{
			p.SetState(528)
			p.Match(JavaScriptParserComma)
		}

	}
	{
		p.SetState(531)
		p.Match(JavaScriptParserCloseBrace)
	}

	return localctx
}

// IPropertyAssignmentContext is an interface to support dynamic dispatch.
type IPropertyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyAssignmentContext differentiates from other interfaces.
	IsPropertyAssignmentContext()
}

type PropertyAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentContext() *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_propertyAssignment
	return p
}

func (*PropertyAssignmentContext) IsPropertyAssignmentContext() {}

func NewPropertyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_propertyAssignment

	return p
}

func (s *PropertyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentContext) CopyFrom(ctx *PropertyAssignmentContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PropertyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PropertyExpressionAssignmentContext struct {
	*PropertyAssignmentContext
}

func NewPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyExpressionAssignmentContext {
	var p = new(PropertyExpressionAssignmentContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionAssignmentContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyExpressionAssignmentContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *PropertyExpressionAssignmentContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *PropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComputedPropertyExpressionAssignmentContext struct {
	*PropertyAssignmentContext
}

func NewComputedPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComputedPropertyExpressionAssignmentContext {
	var p = new(ComputedPropertyExpressionAssignmentContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *ComputedPropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedPropertyExpressionAssignmentContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *ComputedPropertyExpressionAssignmentContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ComputedPropertyExpressionAssignmentContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitComputedPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyShorthandContext struct {
	*PropertyAssignmentContext
}

func NewPropertyShorthandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyShorthandContext {
	var p = new(PropertyShorthandContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyShorthandContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *PropertyShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertyShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertySetterContext struct {
	*PropertyAssignmentContext
}

func NewPropertySetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertySetterContext {
	var p = new(PropertySetterContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertySetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySetterContext) Setter() ISetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertySetterContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *PropertySetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *PropertySetterContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *PropertySetterContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *PropertySetterContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertySetterContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *PropertySetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertySetter(s)
	}
}

func (s *PropertySetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertySetter(s)
	}
}

func (s *PropertySetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertySetter(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyGetterContext struct {
	*PropertyAssignmentContext
}

func NewPropertyGetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyGetterContext {
	var p = new(PropertyGetterContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyGetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyGetterContext) Getter() IGetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyGetterContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *PropertyGetterContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *PropertyGetterContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *PropertyGetterContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertyGetterContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *PropertyGetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertyGetter(s)
	}
}

func (s *PropertyGetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertyGetter(s)
	}
}

func (s *PropertyGetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertyGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

type MethodPropertyContext struct {
	*PropertyAssignmentContext
}

func NewMethodPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodPropertyContext {
	var p = new(MethodPropertyContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *MethodPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodPropertyContext) GeneratorMethod() IGeneratorMethodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneratorMethodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneratorMethodContext)
}

func (s *MethodPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMethodProperty(s)
	}
}

func (s *MethodPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMethodProperty(s)
	}
}

func (s *MethodPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMethodProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) PropertyAssignment() (localctx IPropertyAssignmentContext) {
	localctx = NewPropertyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, JavaScriptParserRULE_propertyAssignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(533)
			p.PropertyName()
		}
		{
			p.SetState(534)
			_la = p.GetTokenStream().LA(1)

			if !(_la == JavaScriptParserAssign || _la == JavaScriptParserColon) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(535)
			p.singleExpression(0)
		}

	case 2:
		localctx = NewComputedPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(537)
			p.Match(JavaScriptParserOpenBracket)
		}
		{
			p.SetState(538)
			p.singleExpression(0)
		}
		{
			p.SetState(539)
			p.Match(JavaScriptParserCloseBracket)
		}
		{
			p.SetState(540)
			p.Match(JavaScriptParserColon)
		}
		{
			p.SetState(541)
			p.singleExpression(0)
		}

	case 3:
		localctx = NewPropertyGetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(543)
			p.Getter()
		}
		{
			p.SetState(544)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(545)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(546)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(547)
			p.FunctionBody()
		}
		{
			p.SetState(548)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 4:
		localctx = NewPropertySetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(550)
			p.Setter()
		}
		{
			p.SetState(551)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(552)
			p.Match(JavaScriptParserIdentifier)
		}
		{
			p.SetState(553)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(554)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(555)
			p.FunctionBody()
		}
		{
			p.SetState(556)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 5:
		localctx = NewMethodPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(558)
			p.GeneratorMethod()
		}

	case 6:
		localctx = NewPropertyShorthandContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(559)
			p.Match(JavaScriptParserIdentifier)
		}

	}

	return localctx
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_propertyName
	return p
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) IdentifierName() IIdentifierNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *PropertyNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *PropertyNameContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPropertyName(s)
	}
}

func (s *PropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPropertyName(s)
	}
}

func (s *PropertyNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPropertyName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) PropertyName() (localctx IPropertyNameContext) {
	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, JavaScriptParserRULE_propertyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserImplements, JavaScriptParserLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserYield, JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(562)
			p.IdentifierName()
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(563)
			p.Match(JavaScriptParserStringLiteral)
		}

	case JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(564)
			p.NumericLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ArgumentsContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ArgumentsContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *ArgumentsContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsContext) LastArgument() ILastArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILastArgumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILastArgumentContext)
}

func (s *ArgumentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ArgumentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, JavaScriptParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(567)
		p.Match(JavaScriptParserOpenParen)
	}
	p.SetState(581)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserRegularExpressionLiteral, JavaScriptParserOpenBracket, JavaScriptParserOpenParen, JavaScriptParserOpenBrace, JavaScriptParserPlusPlus, JavaScriptParserMinusMinus, JavaScriptParserPlus, JavaScriptParserMinus, JavaScriptParserBitNot, JavaScriptParserNot, JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral, JavaScriptParserTypeof, JavaScriptParserNew, JavaScriptParserVoid, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserDelete, JavaScriptParserClass, JavaScriptParserSuper, JavaScriptParserIdentifier, JavaScriptParserStringLiteral, JavaScriptParserTemplateStringLiteral:
		{
			p.SetState(568)
			p.singleExpression(0)
		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(569)
					p.Match(JavaScriptParserComma)
				}
				{
					p.SetState(570)
					p.singleExpression(0)
				}

			}
			p.SetState(575)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserComma {
			{
				p.SetState(576)
				p.Match(JavaScriptParserComma)
			}
			{
				p.SetState(577)
				p.LastArgument()
			}

		}

	case JavaScriptParserEllipsis:
		{
			p.SetState(580)
			p.LastArgument()
		}

	case JavaScriptParserCloseParen:

	default:
	}
	{
		p.SetState(583)
		p.Match(JavaScriptParserCloseParen)
	}

	return localctx
}

// ILastArgumentContext is an interface to support dynamic dispatch.
type ILastArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastArgumentContext differentiates from other interfaces.
	IsLastArgumentContext()
}

type LastArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastArgumentContext() *LastArgumentContext {
	var p = new(LastArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_lastArgument
	return p
}

func (*LastArgumentContext) IsLastArgumentContext() {}

func NewLastArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastArgumentContext {
	var p = new(LastArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_lastArgument

	return p
}

func (s *LastArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *LastArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEllipsis, 0)
}

func (s *LastArgumentContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *LastArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLastArgument(s)
	}
}

func (s *LastArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLastArgument(s)
	}
}

func (s *LastArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLastArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) LastArgument() (localctx ILastArgumentContext) {
	localctx = NewLastArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, JavaScriptParserRULE_lastArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)
		p.Match(JavaScriptParserEllipsis)
	}
	{
		p.SetState(586)
		p.Match(JavaScriptParserIdentifier)
	}

	return localctx
}

// IExpressionSequenceContext is an interface to support dynamic dispatch.
type IExpressionSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionSequenceContext differentiates from other interfaces.
	IsExpressionSequenceContext()
}

type ExpressionSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSequenceContext() *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_expressionSequence
	return p
}

func (*ExpressionSequenceContext) IsExpressionSequenceContext() {}

func NewExpressionSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_expressionSequence

	return p
}

func (s *ExpressionSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSequenceContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionSequenceContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExpressionSequenceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(JavaScriptParserComma)
}

func (s *ExpressionSequenceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(JavaScriptParserComma, i)
}

func (s *ExpressionSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitExpressionSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ExpressionSequence() (localctx IExpressionSequenceContext) {
	localctx = NewExpressionSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, JavaScriptParserRULE_expressionSequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.singleExpression(0)
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(589)
				p.Match(JavaScriptParserComma)
			}
			{
				p.SetState(590)
				p.singleExpression(0)
			}

		}
		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())
	}

	return localctx
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_singleExpression
	return p
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) CopyFrom(ctx *SingleExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TemplateStringExpressionContext struct {
	*SingleExpressionContext
}

func NewTemplateStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TemplateStringExpressionContext {
	var p = new(TemplateStringExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TemplateStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringExpressionContext) TemplateStringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTemplateStringLiteral, 0)
}

func (s *TemplateStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTemplateStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TernaryExpressionContext struct {
	*SingleExpressionContext
}

func NewTernaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TernaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *TernaryExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TernaryExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserQuestionMark, 0)
}

func (s *TernaryExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserColon, 0)
}

func (s *TernaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTernaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalAndExpressionContext struct {
	*SingleExpressionContext
}

func NewLogicalAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalAndExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAnd, 0)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLogicalAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreIncrementExpressionContext struct {
	*SingleExpressionContext
}

func NewPreIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusPlus, 0)
}

func (s *PreIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPreIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjectLiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewObjectLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectLiteralExpressionContext {
	var p = new(ObjectLiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ObjectLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *ObjectLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitObjectLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InExpressionContext struct {
	*SingleExpressionContext
}

func NewInExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InExpressionContext {
	var p = new(InExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *InExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *InExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InExpressionContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *InExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterInExpression(s)
	}
}

func (s *InExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitInExpression(s)
	}
}

func (s *InExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitInExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalOrExpressionContext struct {
	*SingleExpressionContext
}

func NewLogicalOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalOrExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOr, 0)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLogicalOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	*SingleExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNot, 0)
}

func (s *NotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreDecreaseExpressionContext struct {
	*SingleExpressionContext
}

func NewPreDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreDecreaseExpressionContext {
	var p = new(PreDecreaseExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusMinus, 0)
}

func (s *PreDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPreDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArgumentsExpressionContext struct {
	*SingleExpressionContext
}

func NewArgumentsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArgumentsExpressionContext {
	var p = new(ArgumentsExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArgumentsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsExpressionContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArgumentsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ThisExpressionContext struct {
	*SingleExpressionContext
}

func NewThisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) This() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThis, 0)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (s *ThisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitThisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionExpressionContext struct {
	*SingleExpressionContext
}

func NewFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) Function() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction, 0)
}

func (s *FunctionExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *FunctionExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *FunctionExpressionContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *FunctionExpressionContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionExpressionContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *FunctionExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *FunctionExpressionContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryMinusExpressionContext struct {
	*SingleExpressionContext
}

func NewUnaryMinusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryMinusExpressionContext {
	var p = new(UnaryMinusExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryMinusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryMinusExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinus, 0)
}

func (s *UnaryMinusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryMinusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitUnaryMinusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentExpressionContext struct {
	*SingleExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentExpressionContext) Assign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserAssign, 0)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostDecreaseExpressionContext struct {
	*SingleExpressionContext
}

func NewPostDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostDecreaseExpressionContext {
	var p = new(PostDecreaseExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusMinus, 0)
}

func (s *PostDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPostDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeofExpressionContext struct {
	*SingleExpressionContext
}

func NewTypeofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TypeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeofExpressionContext) Typeof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTypeof, 0)
}

func (s *TypeofExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TypeofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitTypeofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InstanceofExpressionContext struct {
	*SingleExpressionContext
}

func NewInstanceofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceofExpressionContext {
	var p = new(InstanceofExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *InstanceofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *InstanceofExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InstanceofExpressionContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInstanceof, 0)
}

func (s *InstanceofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterInstanceofExpression(s)
	}
}

func (s *InstanceofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitInstanceofExpression(s)
	}
}

func (s *InstanceofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitInstanceofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryPlusExpressionContext struct {
	*SingleExpressionContext
}

func NewUnaryPlusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPlusExpressionContext {
	var p = new(UnaryPlusExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryPlusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlus, 0)
}

func (s *UnaryPlusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryPlusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitUnaryPlusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeleteExpressionContext struct {
	*SingleExpressionContext
}

func NewDeleteExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *DeleteExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteExpressionContext) Delete() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDelete, 0)
}

func (s *DeleteExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DeleteExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitDeleteExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowFunctionExpressionContext struct {
	*SingleExpressionContext
}

func NewArrowFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowFunctionExpressionContext {
	var p = new(ArrowFunctionExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrowFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionExpressionContext) ArrowFunctionParameters() IArrowFunctionParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrowFunctionParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionParametersContext)
}

func (s *ArrowFunctionExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserARROW, 0)
}

func (s *ArrowFunctionExpressionContext) ArrowFunctionBody() IArrowFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrowFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionBodyContext)
}

func (s *ArrowFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrowFunctionExpression(s)
	}
}

func (s *ArrowFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrowFunctionExpression(s)
	}
}

func (s *ArrowFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrowFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExpressionContext struct {
	*SingleExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *EqualityExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EqualityExpressionContext) Equals_() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEquals_, 0)
}

func (s *EqualityExpressionContext) NotEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNotEquals, 0)
}

func (s *EqualityExpressionContext) IdentityEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentityEquals, 0)
}

func (s *EqualityExpressionContext) IdentityNotEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentityNotEquals, 0)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitXOrExpressionContext struct {
	*SingleExpressionContext
}

func NewBitXOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitXOrExpressionContext {
	var p = new(BitXOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitXOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitXOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *BitXOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitXOrExpressionContext) BitXOr() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitXOr, 0)
}

func (s *BitXOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitXOrExpression(s)
	}
}

func (s *BitXOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitXOrExpression(s)
	}
}

func (s *BitXOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitXOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SuperExpressionContext struct {
	*SingleExpressionContext
}

func NewSuperExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) Super() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSuper, 0)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

func (s *SuperExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSuperExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeExpressionContext struct {
	*SingleExpressionContext
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MultiplicativeExpressionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiply, 0)
}

func (s *MultiplicativeExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDivide, 0)
}

func (s *MultiplicativeExpressionContext) Modulus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserModulus, 0)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitShiftExpressionContext struct {
	*SingleExpressionContext
}

func NewBitShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitShiftExpressionContext {
	var p = new(BitShiftExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitShiftExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *BitShiftExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitShiftExpressionContext) LeftShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLeftShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftLogical() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftLogical, 0)
}

func (s *BitShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitShiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	*SingleExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ParenthesizedExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ParenthesizedExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveExpressionContext struct {
	*SingleExpressionContext
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AdditiveExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlus, 0)
}

func (s *AdditiveExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinus, 0)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationalExpressionContext struct {
	*SingleExpressionContext
}

func NewRelationalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *RelationalExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RelationalExpressionContext) LessThan() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLessThan, 0)
}

func (s *RelationalExpressionContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMoreThan, 0)
}

func (s *RelationalExpressionContext) LessThanEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLessThanEquals, 0)
}

func (s *RelationalExpressionContext) GreaterThanEquals() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserGreaterThanEquals, 0)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitRelationalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostIncrementExpressionContext struct {
	*SingleExpressionContext
}

func NewPostIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusPlus, 0)
}

func (s *PostIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitPostIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitNotExpressionContext struct {
	*SingleExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) BitNot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitNot, 0)
}

func (s *BitNotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NewExpressionContext struct {
	*SingleExpressionContext
}

func NewNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExpressionContext {
	var p = new(NewExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *NewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNew, 0)
}

func (s *NewExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NewExpressionContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterNewExpression(s)
	}
}

func (s *NewExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitNewExpression(s)
	}
}

func (s *NewExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitNewExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayLiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewArrayLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralExpressionContext {
	var p = new(ArrayLiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrayLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrayLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberDotExpressionContext struct {
	*SingleExpressionContext
}

func NewMemberDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberDotExpressionContext {
	var p = new(MemberDotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberDotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberDotExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDot, 0)
}

func (s *MemberDotExpressionContext) IdentifierName() IIdentifierNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MemberDotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMemberDotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ClassExpressionContext struct {
	*SingleExpressionContext
}

func NewClassExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassExpressionContext {
	var p = new(ClassExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ClassExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassExpressionContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *ClassExpressionContext) ClassTail() IClassTailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ClassExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterClassExpression(s)
	}
}

func (s *ClassExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitClassExpression(s)
	}
}

func (s *ClassExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitClassExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberIndexExpressionContext struct {
	*SingleExpressionContext
}

func NewMemberIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberIndexExpressionContext {
	var p = new(MemberIndexExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberIndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberIndexExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberIndexExpressionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBracket, 0)
}

func (s *MemberIndexExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *MemberIndexExpressionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBracket, 0)
}

func (s *MemberIndexExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitMemberIndexExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierExpressionContext struct {
	*SingleExpressionContext
}

func NewIdentifierExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierExpressionContext {
	var p = new(IdentifierExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *IdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *IdentifierExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitIdentifierExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitAndExpressionContext struct {
	*SingleExpressionContext
}

func NewBitAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndExpressionContext {
	var p = new(BitAndExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *BitAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitAndExpressionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitAnd, 0)
}

func (s *BitAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitOrExpressionContext struct {
	*SingleExpressionContext
}

func NewBitOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrExpressionContext {
	var p = new(BitOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *BitOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitOrExpressionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitOr, 0)
}

func (s *BitOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitBitOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentOperatorExpressionContext struct {
	*SingleExpressionContext
}

func NewAssignmentOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentOperatorExpressionContext {
	var p = new(AssignmentOperatorExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *AssignmentOperatorExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentOperatorExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAssignmentOperatorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type VoidExpressionContext struct {
	*SingleExpressionContext
}

func NewVoidExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VoidExpressionContext {
	var p = new(VoidExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *VoidExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VoidExpressionContext) Void() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVoid, 0)
}

func (s *VoidExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VoidExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterVoidExpression(s)
	}
}

func (s *VoidExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitVoidExpression(s)
	}
}

func (s *VoidExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitVoidExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) SingleExpression() (localctx ISingleExpressionContext) {
	return p.singleExpression(0)
}

func (p *JavaScriptParser) singleExpression(_p int) (localctx ISingleExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISingleExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 96
	p.EnterRecursionRule(localctx, 96, JavaScriptParserRULE_singleExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(597)
			p.Match(JavaScriptParserFunction)
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserIdentifier {
			{
				p.SetState(598)
				p.Match(JavaScriptParserIdentifier)
			}

		}
		{
			p.SetState(601)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserEllipsis))) != 0) || _la == JavaScriptParserIdentifier {
			{
				p.SetState(602)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(605)
			p.Match(JavaScriptParserCloseParen)
		}
		{
			p.SetState(606)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(607)
			p.FunctionBody()
		}
		{
			p.SetState(608)
			p.Match(JavaScriptParserCloseBrace)
		}

	case 2:
		localctx = NewClassExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(610)
			p.Match(JavaScriptParserClass)
		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JavaScriptParserIdentifier {
			{
				p.SetState(611)
				p.Match(JavaScriptParserIdentifier)
			}

		}
		{
			p.SetState(614)
			p.ClassTail()
		}

	case 3:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(615)
			p.Match(JavaScriptParserNew)
		}
		{
			p.SetState(616)
			p.singleExpression(0)
		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(617)
				p.Arguments()
			}

		}

	case 4:
		localctx = NewDeleteExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(620)
			p.Match(JavaScriptParserDelete)
		}
		{
			p.SetState(621)
			p.singleExpression(33)
		}

	case 5:
		localctx = NewVoidExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(622)
			p.Match(JavaScriptParserVoid)
		}
		{
			p.SetState(623)
			p.singleExpression(32)
		}

	case 6:
		localctx = NewTypeofExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(624)
			p.Match(JavaScriptParserTypeof)
		}
		{
			p.SetState(625)
			p.singleExpression(31)
		}

	case 7:
		localctx = NewPreIncrementExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(626)
			p.Match(JavaScriptParserPlusPlus)
		}
		{
			p.SetState(627)
			p.singleExpression(30)
		}

	case 8:
		localctx = NewPreDecreaseExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(628)
			p.Match(JavaScriptParserMinusMinus)
		}
		{
			p.SetState(629)
			p.singleExpression(29)
		}

	case 9:
		localctx = NewUnaryPlusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(630)
			p.Match(JavaScriptParserPlus)
		}
		{
			p.SetState(631)
			p.singleExpression(28)
		}

	case 10:
		localctx = NewUnaryMinusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(632)
			p.Match(JavaScriptParserMinus)
		}
		{
			p.SetState(633)
			p.singleExpression(27)
		}

	case 11:
		localctx = NewBitNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(634)
			p.Match(JavaScriptParserBitNot)
		}
		{
			p.SetState(635)
			p.singleExpression(26)
		}

	case 12:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(636)
			p.Match(JavaScriptParserNot)
		}
		{
			p.SetState(637)
			p.singleExpression(25)
		}

	case 13:
		localctx = NewThisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(638)
			p.Match(JavaScriptParserThis)
		}

	case 14:
		localctx = NewIdentifierExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(639)
			p.Match(JavaScriptParserIdentifier)
		}

	case 15:
		localctx = NewSuperExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(640)
			p.Match(JavaScriptParserSuper)
		}

	case 16:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(641)
			p.Literal()
		}

	case 17:
		localctx = NewArrayLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(642)
			p.ArrayLiteral()
		}

	case 18:
		localctx = NewObjectLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(643)
			p.ObjectLiteral()
		}

	case 19:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(644)
			p.Match(JavaScriptParserOpenParen)
		}
		{
			p.SetState(645)
			p.ExpressionSequence()
		}
		{
			p.SetState(646)
			p.Match(JavaScriptParserCloseParen)
		}

	case 20:
		localctx = NewArrowFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(648)
			p.ArrowFunctionParameters()
		}
		{
			p.SetState(649)
			p.Match(JavaScriptParserARROW)
		}
		{
			p.SetState(650)
			p.ArrowFunctionBody()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(721)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
			case 1:
				localctx = NewMultiplicativeExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(654)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
				}
				{
					p.SetState(655)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserMultiply)|(1<<JavaScriptParserDivide)|(1<<JavaScriptParserModulus))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(656)
					p.singleExpression(25)
				}

			case 2:
				localctx = NewAdditiveExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(657)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				{
					p.SetState(658)
					_la = p.GetTokenStream().LA(1)

					if !(_la == JavaScriptParserPlus || _la == JavaScriptParserMinus) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(659)
					p.singleExpression(24)
				}

			case 3:
				localctx = NewBitShiftExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(660)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(661)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserRightShiftArithmetic)|(1<<JavaScriptParserLeftShiftArithmetic)|(1<<JavaScriptParserRightShiftLogical))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(662)
					p.singleExpression(23)
				}

			case 4:
				localctx = NewRelationalExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(663)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(664)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(JavaScriptParserLessThan-29))|(1<<(JavaScriptParserMoreThan-29))|(1<<(JavaScriptParserLessThanEquals-29))|(1<<(JavaScriptParserGreaterThanEquals-29)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(665)
					p.singleExpression(22)
				}

			case 5:
				localctx = NewInstanceofExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(666)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(667)
					p.Match(JavaScriptParserInstanceof)
				}
				{
					p.SetState(668)
					p.singleExpression(21)
				}

			case 6:
				localctx = NewInExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(669)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(670)
					p.Match(JavaScriptParserIn)
				}
				{
					p.SetState(671)
					p.singleExpression(20)
				}

			case 7:
				localctx = NewEqualityExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(672)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(673)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(JavaScriptParserEquals_-33))|(1<<(JavaScriptParserNotEquals-33))|(1<<(JavaScriptParserIdentityEquals-33))|(1<<(JavaScriptParserIdentityNotEquals-33)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(674)
					p.singleExpression(19)
				}

			case 8:
				localctx = NewBitAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(675)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(676)
					p.Match(JavaScriptParserBitAnd)
				}
				{
					p.SetState(677)
					p.singleExpression(18)
				}

			case 9:
				localctx = NewBitXOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(678)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(679)
					p.Match(JavaScriptParserBitXOr)
				}
				{
					p.SetState(680)
					p.singleExpression(17)
				}

			case 10:
				localctx = NewBitOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(681)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(682)
					p.Match(JavaScriptParserBitOr)
				}
				{
					p.SetState(683)
					p.singleExpression(16)
				}

			case 11:
				localctx = NewLogicalAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(684)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(685)
					p.Match(JavaScriptParserAnd)
				}
				{
					p.SetState(686)
					p.singleExpression(15)
				}

			case 12:
				localctx = NewLogicalOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(687)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(688)
					p.Match(JavaScriptParserOr)
				}
				{
					p.SetState(689)
					p.singleExpression(14)
				}

			case 13:
				localctx = NewTernaryExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(690)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(691)
					p.Match(JavaScriptParserQuestionMark)
				}
				{
					p.SetState(692)
					p.singleExpression(0)
				}
				{
					p.SetState(693)
					p.Match(JavaScriptParserColon)
				}
				{
					p.SetState(694)
					p.singleExpression(13)
				}

			case 14:
				localctx = NewAssignmentExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(696)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(697)
					p.Match(JavaScriptParserAssign)
				}
				{
					p.SetState(698)
					p.singleExpression(12)
				}

			case 15:
				localctx = NewAssignmentOperatorExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(699)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(700)
					p.AssignmentOperator()
				}
				{
					p.SetState(701)
					p.singleExpression(11)
				}

			case 16:
				localctx = NewMemberIndexExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(703)

				if !(p.Precpred(p.GetParserRuleContext(), 39)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 39)", ""))
				}
				{
					p.SetState(704)
					p.Match(JavaScriptParserOpenBracket)
				}
				{
					p.SetState(705)
					p.ExpressionSequence()
				}
				{
					p.SetState(706)
					p.Match(JavaScriptParserCloseBracket)
				}

			case 17:
				localctx = NewMemberDotExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(708)

				if !(p.Precpred(p.GetParserRuleContext(), 38)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 38)", ""))
				}
				{
					p.SetState(709)
					p.Match(JavaScriptParserDot)
				}
				{
					p.SetState(710)
					p.IdentifierName()
				}

			case 18:
				localctx = NewArgumentsExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(711)

				if !(p.Precpred(p.GetParserRuleContext(), 37)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 37)", ""))
				}
				{
					p.SetState(712)
					p.Arguments()
				}

			case 19:
				localctx = NewPostIncrementExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(713)

				if !(p.Precpred(p.GetParserRuleContext(), 35)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 35)", ""))
				}
				p.SetState(714)

				if !(p.notLineTerminator()) {
					panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
				}
				{
					p.SetState(715)
					p.Match(JavaScriptParserPlusPlus)
				}

			case 20:
				localctx = NewPostDecreaseExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(716)

				if !(p.Precpred(p.GetParserRuleContext(), 34)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 34)", ""))
				}
				p.SetState(717)

				if !(p.notLineTerminator()) {
					panic(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
				}
				{
					p.SetState(718)
					p.Match(JavaScriptParserMinusMinus)
				}

			case 21:
				localctx = NewTemplateStringExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, JavaScriptParserRULE_singleExpression)
				p.SetState(719)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(720)
					p.Match(JavaScriptParserTemplateStringLiteral)
				}

			}

		}
		p.SetState(725)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}

	return localctx
}

// IArrowFunctionParametersContext is an interface to support dynamic dispatch.
type IArrowFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionParametersContext differentiates from other interfaces.
	IsArrowFunctionParametersContext()
}

type ArrowFunctionParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionParametersContext() *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionParameters
	return p
}

func (*ArrowFunctionParametersContext) IsArrowFunctionParametersContext() {}

func NewArrowFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionParameters

	return p
}

func (s *ArrowFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionParametersContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *ArrowFunctionParametersContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenParen, 0)
}

func (s *ArrowFunctionParametersContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseParen, 0)
}

func (s *ArrowFunctionParametersContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ArrowFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrowFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ArrowFunctionParameters() (localctx IArrowFunctionParametersContext) {
	localctx = NewArrowFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, JavaScriptParserRULE_arrowFunctionParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(732)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(726)
			p.Match(JavaScriptParserIdentifier)
		}

	case JavaScriptParserOpenParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(727)
			p.Match(JavaScriptParserOpenParen)
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JavaScriptParserOpenBracket)|(1<<JavaScriptParserOpenBrace)|(1<<JavaScriptParserEllipsis))) != 0) || _la == JavaScriptParserIdentifier {
			{
				p.SetState(728)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(731)
			p.Match(JavaScriptParserCloseParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrowFunctionBodyContext is an interface to support dynamic dispatch.
type IArrowFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionBodyContext differentiates from other interfaces.
	IsArrowFunctionBodyContext()
}

type ArrowFunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionBodyContext() *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionBody
	return p
}

func (*ArrowFunctionBodyContext) IsArrowFunctionBodyContext() {}

func NewArrowFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_arrowFunctionBody

	return p
}

func (s *ArrowFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionBodyContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrowFunctionBodyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOpenBrace, 0)
}

func (s *ArrowFunctionBodyContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ArrowFunctionBodyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCloseBrace, 0)
}

func (s *ArrowFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterArrowFunctionBody(s)
	}
}

func (s *ArrowFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitArrowFunctionBody(s)
	}
}

func (s *ArrowFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitArrowFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ArrowFunctionBody() (localctx IArrowFunctionBodyContext) {
	localctx = NewArrowFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, JavaScriptParserRULE_arrowFunctionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(734)
			p.singleExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(735)
			p.Match(JavaScriptParserOpenBrace)
		}
		{
			p.SetState(736)
			p.FunctionBody()
		}
		{
			p.SetState(737)
			p.Match(JavaScriptParserCloseBrace)
		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) MultiplyAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMultiplyAssign, 0)
}

func (s *AssignmentOperatorContext) DivideAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDivideAssign, 0)
}

func (s *AssignmentOperatorContext) ModulusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserModulusAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLeftShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftLogicalAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRightShiftLogicalAssign, 0)
}

func (s *AssignmentOperatorContext) BitAndAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitAndAssign, 0)
}

func (s *AssignmentOperatorContext) BitXorAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitXorAssign, 0)
}

func (s *AssignmentOperatorContext) BitOrAssign() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBitOrAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, JavaScriptParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(JavaScriptParserMultiplyAssign-42))|(1<<(JavaScriptParserDivideAssign-42))|(1<<(JavaScriptParserModulusAssign-42))|(1<<(JavaScriptParserPlusAssign-42))|(1<<(JavaScriptParserMinusAssign-42))|(1<<(JavaScriptParserLeftShiftArithmeticAssign-42))|(1<<(JavaScriptParserRightShiftArithmeticAssign-42))|(1<<(JavaScriptParserRightShiftLogicalAssign-42))|(1<<(JavaScriptParserBitAndAssign-42))|(1<<(JavaScriptParserBitXorAssign-42))|(1<<(JavaScriptParserBitOrAssign-42)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNullLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBooleanLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStringLiteral, 0)
}

func (s *LiteralContext) TemplateStringLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTemplateStringLiteral, 0)
}

func (s *LiteralContext) RegularExpressionLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserRegularExpressionLiteral, 0)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, JavaScriptParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(749)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(743)
			p.Match(JavaScriptParserNullLiteral)
		}

	case JavaScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(744)
			p.Match(JavaScriptParserBooleanLiteral)
		}

	case JavaScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(745)
			p.Match(JavaScriptParserStringLiteral)
		}

	case JavaScriptParserTemplateStringLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(746)
			p.Match(JavaScriptParserTemplateStringLiteral)
		}

	case JavaScriptParserRegularExpressionLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(747)
			p.Match(JavaScriptParserRegularExpressionLiteral)
		}

	case JavaScriptParserDecimalLiteral, JavaScriptParserHexIntegerLiteral, JavaScriptParserOctalIntegerLiteral, JavaScriptParserOctalIntegerLiteral2, JavaScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(748)
			p.NumericLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDecimalLiteral, 0)
}

func (s *NumericLiteralContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserHexIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOctalIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral2() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserOctalIntegerLiteral2, 0)
}

func (s *NumericLiteralContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBinaryIntegerLiteral, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, JavaScriptParserRULE_numericLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(751)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-56)&-(0x1f+1)) == 0 && ((1<<uint((_la-56)))&((1<<(JavaScriptParserDecimalLiteral-56))|(1<<(JavaScriptParserHexIntegerLiteral-56))|(1<<(JavaScriptParserOctalIntegerLiteral-56))|(1<<(JavaScriptParserOctalIntegerLiteral2-56))|(1<<(JavaScriptParserBinaryIntegerLiteral-56)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierNameContext is an interface to support dynamic dispatch.
type IIdentifierNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierNameContext differentiates from other interfaces.
	IsIdentifierNameContext()
}

type IdentifierNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierNameContext() *IdentifierNameContext {
	var p = new(IdentifierNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_identifierName
	return p
}

func (*IdentifierNameContext) IsIdentifierNameContext() {}

func NewIdentifierNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierNameContext {
	var p = new(IdentifierNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_identifierName

	return p
}

func (s *IdentifierNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *IdentifierNameContext) ReservedWord() IReservedWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReservedWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *IdentifierNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterIdentifierName(s)
	}
}

func (s *IdentifierNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitIdentifierName(s)
	}
}

func (s *IdentifierNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitIdentifierName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) IdentifierName() (localctx IIdentifierNameContext) {
	localctx = NewIdentifierNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, JavaScriptParserRULE_identifierName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(755)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(753)
			p.Match(JavaScriptParserIdentifier)
		}

	case JavaScriptParserNullLiteral, JavaScriptParserBooleanLiteral, JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserImplements, JavaScriptParserLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserYield:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(754)
			p.ReservedWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_reservedWord
	return p
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ReservedWordContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNullLiteral, 0)
}

func (s *ReservedWordContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBooleanLiteral, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (s *ReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, JavaScriptParserRULE_reservedWord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(760)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JavaScriptParserBreak, JavaScriptParserDo, JavaScriptParserInstanceof, JavaScriptParserTypeof, JavaScriptParserCase, JavaScriptParserElse, JavaScriptParserNew, JavaScriptParserVar, JavaScriptParserCatch, JavaScriptParserFinally, JavaScriptParserReturn, JavaScriptParserVoid, JavaScriptParserContinue, JavaScriptParserFor, JavaScriptParserSwitch, JavaScriptParserWhile, JavaScriptParserDebugger, JavaScriptParserFunction, JavaScriptParserThis, JavaScriptParserWith, JavaScriptParserDefault, JavaScriptParserIf, JavaScriptParserThrow, JavaScriptParserDelete, JavaScriptParserIn, JavaScriptParserTry, JavaScriptParserClass, JavaScriptParserEnum, JavaScriptParserExtends, JavaScriptParserSuper, JavaScriptParserConst, JavaScriptParserExport, JavaScriptParserImport, JavaScriptParserImplements, JavaScriptParserLet, JavaScriptParserPrivate, JavaScriptParserPublic, JavaScriptParserInterface, JavaScriptParserPackage, JavaScriptParserProtected, JavaScriptParserStatic, JavaScriptParserYield:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(757)
			p.Keyword()
		}

	case JavaScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(758)
			p.Match(JavaScriptParserNullLiteral)
		}

	case JavaScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(759)
			p.Match(JavaScriptParserBooleanLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Break() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserBreak, 0)
}

func (s *KeywordContext) Do() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDo, 0)
}

func (s *KeywordContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInstanceof, 0)
}

func (s *KeywordContext) Typeof() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTypeof, 0)
}

func (s *KeywordContext) Case() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCase, 0)
}

func (s *KeywordContext) Else() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserElse, 0)
}

func (s *KeywordContext) New() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserNew, 0)
}

func (s *KeywordContext) Var() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVar, 0)
}

func (s *KeywordContext) Catch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserCatch, 0)
}

func (s *KeywordContext) Finally() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFinally, 0)
}

func (s *KeywordContext) Return() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserReturn, 0)
}

func (s *KeywordContext) Void() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserVoid, 0)
}

func (s *KeywordContext) Continue() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserContinue, 0)
}

func (s *KeywordContext) For() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFor, 0)
}

func (s *KeywordContext) Switch() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSwitch, 0)
}

func (s *KeywordContext) While() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWhile, 0)
}

func (s *KeywordContext) Debugger() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDebugger, 0)
}

func (s *KeywordContext) Function() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserFunction, 0)
}

func (s *KeywordContext) This() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThis, 0)
}

func (s *KeywordContext) With() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserWith, 0)
}

func (s *KeywordContext) Default() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDefault, 0)
}

func (s *KeywordContext) If() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIf, 0)
}

func (s *KeywordContext) Throw() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserThrow, 0)
}

func (s *KeywordContext) Delete() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserDelete, 0)
}

func (s *KeywordContext) In() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIn, 0)
}

func (s *KeywordContext) Try() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserTry, 0)
}

func (s *KeywordContext) Class() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserClass, 0)
}

func (s *KeywordContext) Enum() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEnum, 0)
}

func (s *KeywordContext) Extends() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExtends, 0)
}

func (s *KeywordContext) Super() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSuper, 0)
}

func (s *KeywordContext) Const() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserConst, 0)
}

func (s *KeywordContext) Export() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserExport, 0)
}

func (s *KeywordContext) Import() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImport, 0)
}

func (s *KeywordContext) Implements() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserImplements, 0)
}

func (s *KeywordContext) Let() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserLet, 0)
}

func (s *KeywordContext) Private() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPrivate, 0)
}

func (s *KeywordContext) Public() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPublic, 0)
}

func (s *KeywordContext) Interface() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserInterface, 0)
}

func (s *KeywordContext) Package() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserPackage, 0)
}

func (s *KeywordContext) Protected() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserProtected, 0)
}

func (s *KeywordContext) Static() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserStatic, 0)
}

func (s *KeywordContext) Yield() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserYield, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, JavaScriptParserRULE_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(JavaScriptParserBreak-61))|(1<<(JavaScriptParserDo-61))|(1<<(JavaScriptParserInstanceof-61))|(1<<(JavaScriptParserTypeof-61))|(1<<(JavaScriptParserCase-61))|(1<<(JavaScriptParserElse-61))|(1<<(JavaScriptParserNew-61))|(1<<(JavaScriptParserVar-61))|(1<<(JavaScriptParserCatch-61))|(1<<(JavaScriptParserFinally-61))|(1<<(JavaScriptParserReturn-61))|(1<<(JavaScriptParserVoid-61))|(1<<(JavaScriptParserContinue-61))|(1<<(JavaScriptParserFor-61))|(1<<(JavaScriptParserSwitch-61))|(1<<(JavaScriptParserWhile-61))|(1<<(JavaScriptParserDebugger-61))|(1<<(JavaScriptParserFunction-61))|(1<<(JavaScriptParserThis-61))|(1<<(JavaScriptParserWith-61))|(1<<(JavaScriptParserDefault-61))|(1<<(JavaScriptParserIf-61))|(1<<(JavaScriptParserThrow-61))|(1<<(JavaScriptParserDelete-61))|(1<<(JavaScriptParserIn-61))|(1<<(JavaScriptParserTry-61))|(1<<(JavaScriptParserClass-61))|(1<<(JavaScriptParserEnum-61))|(1<<(JavaScriptParserExtends-61))|(1<<(JavaScriptParserSuper-61))|(1<<(JavaScriptParserConst-61))|(1<<(JavaScriptParserExport-61)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(JavaScriptParserImport-93))|(1<<(JavaScriptParserImplements-93))|(1<<(JavaScriptParserLet-93))|(1<<(JavaScriptParserPrivate-93))|(1<<(JavaScriptParserPublic-93))|(1<<(JavaScriptParserInterface-93))|(1<<(JavaScriptParserPackage-93))|(1<<(JavaScriptParserProtected-93))|(1<<(JavaScriptParserStatic-93))|(1<<(JavaScriptParserYield-93)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_getter
	return p
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *GetterContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (s *GetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, JavaScriptParserRULE_getter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Match(JavaScriptParserIdentifier)
	}
	p.SetState(765)

	if !(p.p("get")) {
		panic(antlr.NewFailedPredicateException(p, "p.p(\"get\")", ""))
	}
	{
		p.SetState(766)
		p.PropertyName()
	}

	return localctx
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_setter
	return p
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserIdentifier, 0)
}

func (s *SetterContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (s *SetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitSetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, JavaScriptParserRULE_setter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(JavaScriptParserIdentifier)
	}
	p.SetState(769)

	if !(p.p("set")) {
		panic(antlr.NewFailedPredicateException(p, "p.p(\"set\")", ""))
	}
	{
		p.SetState(770)
		p.PropertyName()
	}

	return localctx
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JavaScriptParserRULE_eos
	return p
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JavaScriptParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserSemiColon, 0)
}

func (s *EosContext) EOF() antlr.TerminalNode {
	return s.GetToken(JavaScriptParserEOF, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.EnterEos(s)
	}
}

func (s *EosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JavaScriptParserListener); ok {
		listenerT.ExitEos(s)
	}
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JavaScriptParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JavaScriptParser) Eos() (localctx IEosContext) {
	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, JavaScriptParserRULE_eos)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(772)
			p.Match(JavaScriptParserSemiColon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(773)
			p.Match(JavaScriptParserEOF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(774)

		if !(p.lineTerminatorAhead()) {
			panic(antlr.NewFailedPredicateException(p, "p.lineTerminatorAhead()", ""))
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(775)

		if !(p.closeBrace()) {
			panic(antlr.NewFailedPredicateException(p, "p.closeBrace()", ""))
		}

	}

	return localctx
}

func (p *JavaScriptParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 9:
		var t *ExpressionStatementContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionStatementContext)
		}
		return p.ExpressionStatement_Sempred(t, predIndex)

	case 11:
		var t *IterationStatementContext = nil
		if localctx != nil {
			t = localctx.(*IterationStatementContext)
		}
		return p.IterationStatement_Sempred(t, predIndex)

	case 13:
		var t *ContinueStatementContext = nil
		if localctx != nil {
			t = localctx.(*ContinueStatementContext)
		}
		return p.ContinueStatement_Sempred(t, predIndex)

	case 14:
		var t *BreakStatementContext = nil
		if localctx != nil {
			t = localctx.(*BreakStatementContext)
		}
		return p.BreakStatement_Sempred(t, predIndex)

	case 15:
		var t *ReturnStatementContext = nil
		if localctx != nil {
			t = localctx.(*ReturnStatementContext)
		}
		return p.ReturnStatement_Sempred(t, predIndex)

	case 23:
		var t *ThrowStatementContext = nil
		if localctx != nil {
			t = localctx.(*ThrowStatementContext)
		}
		return p.ThrowStatement_Sempred(t, predIndex)

	case 31:
		var t *ClassElementContext = nil
		if localctx != nil {
			t = localctx.(*ClassElementContext)
		}
		return p.ClassElement_Sempred(t, predIndex)

	case 48:
		var t *SingleExpressionContext = nil
		if localctx != nil {
			t = localctx.(*SingleExpressionContext)
		}
		return p.SingleExpression_Sempred(t, predIndex)

	case 57:
		var t *GetterContext = nil
		if localctx != nil {
			t = localctx.(*GetterContext)
		}
		return p.Getter_Sempred(t, predIndex)

	case 58:
		var t *SetterContext = nil
		if localctx != nil {
			t = localctx.(*SetterContext)
		}
		return p.Setter_Sempred(t, predIndex)

	case 59:
		var t *EosContext = nil
		if localctx != nil {
			t = localctx.(*EosContext)
		}
		return p.Eos_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *JavaScriptParser) ExpressionStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.notOpenBraceAndNotFunction()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) IterationStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.p("of")

	case 2:
		return p.p("of")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ContinueStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) BreakStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ReturnStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ThrowStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) ClassElement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.n("static")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) SingleExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 39)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 38)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 37)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 35)

	case 27:
		return p.notLineTerminator()

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 34)

	case 29:
		return p.notLineTerminator()

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Getter_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 31:
		return p.p("get")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Setter_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 32:
		return p.p("set")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *JavaScriptParser) Eos_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 33:
		return p.lineTerminatorAhead()

	case 34:
		return p.closeBrace()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
